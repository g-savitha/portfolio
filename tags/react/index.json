[{"content":"If you want to fix the position of your footer at the center bottom of your webpage using flexbox layout, you can use the following code:\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;body\u0026gt; \u0026lt;header class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;!-- header content here --\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;!-- main content here --\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer class=\u0026#34;footer\u0026#34;\u0026gt; \u0026lt;!-- footer content here --\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/body\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  html, body { height: 100%; } body { display: flex; flex-direction: column; } .main { flex: 1; } .footer { margin-top: auto; display: flex; flex-direction: column; justify-content: center; align-items: center; }   To achieve this, there are a few things to keep in mind:\n Set the height of the html and body elements to 100% so that they take up the full height of the screen, even if the content is not long enough to fill the entire height. Set the flex property of the .main element to 1, which means it will grow to fill any remaining space in the body element after the header and footer have been sized. Use margin-top: auto on the .footer element to push it to the bottom of the body element and take up any remaining vertical space.  By using percentage-based height on the html and body elements, and flex property on the .main class, the layout can adapt to different screen sizes and resolutions while maintaining a consistent vertical arrangement of header, main content area, and footer. This approach is particularly useful for creating responsive web designs that work well on mobile devices, tablets, and desktops.\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"CSS Snippet","id":19,"section":"posts","tags":["css","snippet"],"title":"Fixing Your Footer Position with Flexbox","uri":"https://gsavitha.in/posts/footer/"},{"content":"What are feature queries? Feature queries are a set of conditional statements that check whether a particular feature is supported by a browser or not. These queries are used to control the behavior of a website by providing fallbacks or alternative styles for browsers that do not support certain features.\nFor example, let\u0026rsquo;s say you want to use the CSS Grid layout in your website. However, not all browsers support CSS Grid. To ensure that your website looks good on all browsers, you can use a feature query to check whether the browser supports CSS Grid. If it does, you can use the CSS Grid layout, and if it doesn\u0026rsquo;t, you can provide a fallback layout that works for all browsers.\n1 2 3 4 5 6 7 8 9 10 11 12 13  /* Use CSS Grid if supported */ @supports (display: grid) { .container { display: grid; grid-template-columns: 1fr 1fr 1fr; } } /* Fallback for browsers that do not support CSS Grid */ .container { display: flex; flex-wrap: wrap; justify-content: space-between; }   In the example above, the @supports rule checks whether the display: grid property is supported by the browser. If it is, the grid-template-columns property is used to create a 3-column grid layout. If not, the .container element is styled using a flexbox layout that wraps items and justifies content between them.\nWhat if \u0026lsquo;@supports\u0026rsquo; isnt supported by the browser? If the @supports rule is not supported by the user\u0026rsquo;s browser, the browser will simply ignore it and move on to the next rule in the stylesheet. This means that any styles or fallbacks that were defined within the @supports rule will not be applied to the page.\nIn this case, it\u0026rsquo;s important to provide alternative styles that work on older or less-capable browsers. This can be done by defining default styles outside of the @supports rule, or by using other techniques such as progressive enhancement or graceful degradation.\nProgressive enhancement involves starting with a basic design and then adding more advanced features for browsers that support them. This ensures that all users have access to the core functionality of the website, while still providing a richer experience for users with modern browsers.\nGraceful degradation, on the other hand, involves starting with a fully-featured design and then scaling back for browsers that don\u0026rsquo;t support certain features. This can be useful when working with older browsers that may not support more modern web technologies.\nIn summary, if the @supports rule is not supported by the user\u0026rsquo;s browser, it\u0026rsquo;s important to provide alternative styles or use other techniques to ensure that the website remains accessible and functional for all users.\nFeature queries in JS? Yes, feature queries can also be used in JavaScript to detect browser support for specific APIs or features. For example, developers can use feature queries in JavaScript to detect support for features like fetch, or WebAssembly. However, feature queries are more commonly associated with CSS, as they are primarily used to detect support for CSS properties and values.\n Checking for fetch support in javascript  1 2 3 4 5 6 7  if (\u0026#39;fetch\u0026#39; in window) { // fetch is supported  // do something here } else { // fetch is not supported  // provide a fallback here }    Checking for WebAssembly support:  1 2 3 4 5 6 7  if (typeof WebAssembly === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; typeof WebAssembly.instantiate === \u0026#39;function\u0026#39;) { // WebAssembly is supported  // do something here } else { // WebAssembly is not supported  // provide a fallback here }   These are just two examples, but feature queries in JavaScript can be used to detect support for a wide range of features, including APIs, browser objects, and browser events.\nUntil next time, Happy learning! 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"Feature queries help us detect browser support for specific features and provide fallbacks for better cross-browser compatibility.","id":20,"section":"posts","tags":["css","javascript","legacy"],"title":"Feature Queries in Web Development","uri":"https://gsavitha.in/posts/feature-quries/"},{"content":"Greetings! 👋,\nWelcome to the first part of the JS Hard Parts: Demystified series. In this post, we will delve into the concepts of callbacks, execution context, functions, and higher-order functions. So let\u0026rsquo;s get started without any delay 🚀\nBefore we proceed, I assume that you already have knowledge of writing loops, functions, and call stack\nFunctions, callbacks and execution context Let\u0026rsquo;s take an example to understand the concepts better. We have a function called copyArrayAndMultiplyBy2 that accepts an array, multiplies each element of the array by 2, and returns the new array.\n1 2 3 4 5 6 7 8 9  function copyArrayAndMultiplyBy2(arr){ const output = []; for(let i = 0; i \u0026lt; arr.length; i++){ output.push(arr[i]*2) } return output } const myArr = [1,2,3]; const result = copyArrayAndMultiplyBy2(myArr);   When this code is interpreted, it executes as follows:\n  A function labeled copyArrayAndMultiplyBy2 with a value of function is created in the global memory (interpreter just has a memory of it, didn\u0026rsquo;t execute it yet). The array myArr is created in the global memory. When result = copyArrayAndMultiplyBy2(myArr) is executed, an execution context is created as soon as it sees (), the arguments passed in become parameters. The interpreter goes to line 2, and copyArrayAndMultiplyBy2 is simultaneously pushed onto the call stack. Now we have access to [1,2,3] inside the local memory, next an empty array with label output is created. A loop is executed, and a new result [2,4,6] is copied into output. Once the value is returned, the value goes back to the global memory, and stores the value of [2,4,6] in the result. As soon as the function is returned, the global execution context is deleted from the memory, and the call from the call stack is popped off.   PS: Remember global() in node.js or window object in javascript is always the first item on the callstack.\n Now, let\u0026rsquo;s suppose we want to divide each element by 2 in the array. We write a similar function, copyArrayAndDivideBy2 with some modification in the logic:\n1 2 3 4 5 6 7 8 9  function copyArrayAndDivideBy2(arr){ const output = []; for(let i = 0; i \u0026lt; arr.length; i++){ output.push(arr[i]/2) } return output } const myArr = [1,2,3]; const result = copyArrayAndDivideBy2(myArr);   This is how it is interpreted :\n Did you observe something? this function violates the D.R.Y (Don\u0026rsquo;t Repeat Yourself) principle.\nCan we optimise this?\nHigher Order Functions (Pass Functionality as a Parameter) We could generalize our function and pass in our specific instruction(pass in the functionality (a.k.a Callback function)) only when we run copyArrAndManipulate using Higher Order Functions (HOF):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function copyArrayAndManipulate(arr, instruction){ const output = []; for(let i = 0; i \u0026lt; arr.length; i++){ output.push(instruction(arr[i])) } return output } function multiplyBy2(input){ return input * 2 } const myArr = [1,2,3]; const result = copyArrayAndManipulate(myArr, multiplyBy2);   In this case, we pass in a specific instruction (the multiplyBy2 callback function) to the copyArrayAndManipulate function. The copyArrayAndManipulate function takes care of executing the multiplyBy2 instruction on each element of myArr and returns the manipulated array result.\n Interpreter executes this as follows:\n Does this function copyArrayAndManipulate remind you of anything?. Yes, it\u0026rsquo;s the polyfill of Arrays.map()\nHow is this possible?\nFunctions in JavaScript are first-class citizens, which means that they are treated like any other value, such as a string, number, or object. This means that functions can be passed as arguments to other functions, returned as values from functions (*a.k.a. HOF *), and stored in variables or data structures just like any other value.\nThis property of functions being first-class citizens is a key aspect of the functional programming paradigm, which emphasizes the use of higher-order functions and treating functions as values that can be manipulated and composed to create more complex functionality.\nHOFs and callbacks make the code simpler, readable, and D.R.Y\nExamples:  Declarative readable code - map(), filter(), reduce() Asynchronous JS - Callbacks are core aspect of async JS and are underhood of promises, async/await  Until next time, Happy coding! 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"Functions, callbacks and execution context","id":21,"section":"posts","tags":["javascript","HOF","Higher Order Functions","execution context","demystified"],"title":"Execution Context Demystified","uri":"https://gsavitha.in/posts/exec-context/"},{"content":"Hello there! 👋\nI\u0026rsquo;m excited to announce the start of a new series on Javascript that aims to provide a deeper understanding of core concepts. Let\u0026rsquo;s dive right in without delay! 🚀\nThis series will cover the following topics:\n  Execution Context, Callbacks, and Higher-Order Functions : This topic will cover the fundamental concepts of the execution context in JavaScript, how callbacks are used in higher-order functions, and why they are essential in modern web development.\n  Closures : This topic will delve into the inner workings of closures in JavaScript, how they help with encapsulation and privacy, and how to use them effectively in your code.\n  Asynchronous Javascript :This topic will introduce the concept of asynchronous programming in JavaScript, how it works with the event loop, and why it is crucial for building modern web applications.\n  Promises : This topic will focus on how promises work in JavaScript, their syntax and usage, and how they help to solve the problem of callback hell.\n  Classes and Prototypes : This topic will explain the concepts of classes and prototypes in JavaScript, how they relate to each other, and how they are used to create reusable code.\n  Iterators:This topic will explore the concept of iterators in JavaScript, how they work, and how they can be used to simplify and streamline code.\n  Generators: This topic will delve into generators in JavaScript, how they differ from regular functions, and how they can be used to create custom iterators.\n   PS: I will be continually updating this series with additional concepts as I explore and delve deeper.\n I hope you find this series informative and enjoyable. Until, next time. Happy learning! 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"This series covers the core foundations of JS in depth","id":22,"section":"posts","tags":["javascript","foundations","demystified"],"title":"JS Hard Parts Demystified: Introduction","uri":"https://gsavitha.in/posts/js-hard-parts/"},{"content":"Hey, there 👋\nWelcome to the 3rd article of the Epic React Series which is based on the workshop EpicReact.dev by Kent C. Dodds. If you haven\u0026rsquo;t read the previous article of this series, I recommend you to go read it first before proceeding further.\n JS Fundamentals for React Intro to Raw React APIs  In the previous article we understood about raw react APIs, especially React.createElement() and ReactDOM.render(). In this article, lets understand what is JSX and its significance.\n** All the examples used in this series are taken from Epic React.dev workshop\nLet\u0026rsquo;s get started\u0026hellip; shall we?\nUsing JSX, it is much easier to understand when reading the code, compared to raw react APIs. It’s a simple HTML-like syntactic sugar on top of the raw React APIs\n1 2 3 4 5  const ui = \u0026lt;h1 id=\u0026#34;greeting\u0026#34;\u0026gt;Hey there\u0026lt;/h1\u0026gt;; // ↓ ↓ ↓ ↓ compiles to ↓ ↓ ↓ ↓  const ui = React.createElement(\u0026#34;h1\u0026#34;, { id: \u0026#34;greeting\u0026#34;, children: \u0026#34;Hey there\u0026#34; });   Since JSX is not understood by javascript compiler, we need a special compiler called Babel which converts the JSX code to JS, so that our JS compiler can undestand.\n  If you would like to see how JSX gets compiled to JS, check out this Babel REPL\n  Generally we’ll compile all of our code at build-time before pushing it to the production. We will not follow the approach of using babel, that we are following in this article, you will understand how to do that in the future articles.\n  Since JS doesnt know which part of code needs to compiled by Babel, we need to specify it by wrapping the JSX code in between \u0026lt;script type=\u0026quot;text/babel\u0026quot;\u0026gt; and \u0026lt;/script\u0026gt; to avoid errors. By looking at type=text/babel JS understands which piece of code needs to be compiled by Babel.\n  To add Babel to your application through CDN:\n1  \u0026lt;script src=\u0026#34;https://unpkg.com/@babel/standalone@7.9.3/babel.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   Lets take our example from previous article and convert it to jsx\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  const rootElement = document.getElementById(\u0026#34;root\u0026#34;); const helloEle = React.createElement(\u0026#34;span\u0026#34;, {}, \u0026#34;Hello\u0026#34;); const worldEle = React.createElement(\u0026#34;span\u0026#34;, {}, \u0026#34;World\u0026#34;); const element = React.createElement(\u0026#34;div\u0026#34;, { className: \u0026#34;container\u0026#34;, children: [helloEle, \u0026#34; \u0026#34;, worldEle], }); //using JSX const element = ( \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;span\u0026gt;Hello\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;World\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; );   You can notice how easier it is to use JSX rather than React.createElement().\nRecommended Read:\n React Docs : Introducing JSX  Props in JSX 1 2 3 4 5 6  const element = React.createElement(\u0026#34;div\u0026#34;, {className:\u0026#34;container\u0026#34;}, children:\u0026#34;Hello world\u0026#34;) //using JSX const element = \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt;Hello world\u0026lt;/div\u0026gt; // we can also write it as const element = \u0026lt;div className=\u0026#34;container\u0026#34; children=\u0026#34;Hello world\u0026#34; /\u0026gt;    Notice that JSX allows us to have a self closing div unlike html and also we use className instead of class. JSX props are camelCased.  With multiple props 1 2 3  const element = React.createElement(\u0026#34;div\u0026#34;, {className:\u0026#34;container\u0026#34;, id:\u0026#34;hw\u0026#34;}, children:\u0026#34;Hello world\u0026#34;) //using jsx const element = \u0026lt;div className=\u0026#34;container\u0026#34; id=\u0026#34;hw\u0026#34;\u0026gt;Hello world\u0026lt;/div\u0026gt;   Interpolation in JSX  “Interpolation” is defined as \u0026ldquo;the insertion of something of a different nature into something else.\u0026rdquo;\n We have already seen interpolation before, using string template literals.\n1 2 3  const greeting = \u0026#34;Sup\u0026#34;; const subject = \u0026#34;World\u0026#34;; const message = `${greeting}${subject}`;   How does this work in JSX? 1 2 3  const className = \u0026#34;container\u0026#34;; const children = \u0026#34;Hello World\u0026#34;; const element = \u0026lt;div className=\u0026#34;hmmm\u0026#34;\u0026gt;how do I make this work?\u0026lt;/div\u0026gt;;   Our goal here is to extract the className (\u0026ldquo;container\u0026rdquo;) and children (\u0026ldquo;Hello World\u0026rdquo;) from the above example to variables and interpolate them in the JSX.\n1 2 3 4 5 6 7  //without interpolation const element = \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt;Hello world\u0026lt;/div\u0026gt;; //using interpolation const name = \u0026#34;container\u0026#34;; const text = \u0026#34;Hello world\u0026#34;; const element = \u0026lt;div className={name}\u0026gt;{text}\u0026lt;/div\u0026gt;;    Notice how we are interpolating data into JSX by wrapping them between curly braces{}  Babel compiles this down to\n1  const element = React.createElement(\u0026#34;div\u0026#34;, { className: name }, text);   Recommended Reads:\n Embedding expressions in JSX Specifying attributes with JSX  Spreading the props Apply props to this code:\n1 2 3 4  const children = \u0026#34;Hello World\u0026#34;; const className = \u0026#34;container\u0026#34;; const props = { children, className }; const element = \u0026lt;div /\u0026gt;; // how do I apply props to this div?   without JSX\n1  const element = React.createElement(\u0026#34;div\u0026#34;, props);   lets say we want to add an id prop, we can add extra props to the element using spread\n1  const element = React.createElement(\u0026#34;div\u0026#34;, { id: \u0026#34;hw\u0026#34; }, ...props);   Using JSX\n1  const element = \u0026lt;div {...props} /\u0026gt;;   If we add an extra prop\n1 2 3 4  const element = \u0026lt;div id=\u0026#34;hw\u0026#34; {...props} /\u0026gt;; //babel converts this to  const element = React.createElement(\u0026#34;div\u0026#34;, _extends({ id: \u0026#34;hw\u0026#34; }, props));   Babel add an extra helper function called _extends() which is basically Object.assign(), which is kind of a what object spread syntax does, its kind of syntactic sugar on top of Object.assign().\n  MDN: Object.assign()\n  Note: The order of inserting props matters. The props which are added later overrides the previous values.\n  1 2 3 4 5 6  const props = { className: \u0026#34;container\u0026#34;, id: \u0026#34;hw\u0026#34; }; const element = \u0026lt;div className=\u0026#34;default\u0026#34; {...props} /\u0026gt;; //className would be container and id is hw  //if we add className after the props  const element = \u0026lt;div {...props} className=\u0026#34;default\u0026#34; /\u0026gt;; // className would be default and id is hw   Recommended Read:\n Spread Attributes  That\u0026rsquo;s all for now, in the next article you\u0026rsquo;ll learn how to create custom components.\nUntil next time 👋, Happy learning! 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"JSX basics and its usage","id":23,"section":"posts","tags":["javascript","react"],"title":"React Fundamentals: Understanding JSX","uri":"https://gsavitha.in/posts/understanding-jsx/"},{"content":"Hey, there 👋\nWelcome to the 2nd article of the Epic React Series which is based on the workshop EpicReact.dev by Kent C. Dodds. If you haven\u0026rsquo;t read previous article of the series, I recommend you to go and read it first before proceeding further.\n JS Fundamentals required to get started with React  In this post you are going to learn the very basics of react with HTML and javascript using raw React APIs. We wont be using any JSX( we will, in the upcoming posts). Many people tend to skip these concepts as working with raw react APIs is difficult to understand, but it is really important to understand these concepts, as you will see in the upcoming articles.\n** All the examples used in this series are taken from Epic React.dev workshop\nBasic JS Hello World Our Goal is to render the \u0026lsquo;Hello world\u0026rsquo; onto page using javascript.\nCurrently our html file looks like this.\n1  \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;   What do we want?\n1 2 3  \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;Hello World\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   Generate DOM Nodes We can achieve our goal by using javascript\u0026rsquo;s document API.\n1 2 3 4 5 6 7 8 9  //Get the root element from DOM const root = document.querySelector(\u0026#34;#root\u0026#34;); //Create a div element with classname and value inside of it const element = document.createElement(\u0026#34;div\u0026#34;); element.textContext = \u0026#34;Hello world\u0026#34;; element.className = \u0026#34;container\u0026#34;; //append element to root root.append(element);   If we want to do the same thing using React\nIntro to RAW React APIs First we need to import react scripts in our code, since javascript doesn\u0026rsquo;t understand what React is. For now lets take the CDN scripts from unpkg\n1 2  \u0026lt;script src=\u0026#34;https://unpkg.com/react@16.7.0/umd/react.production.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/react-dom@16.7.0/umd/react-dom.production.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   Now, the above code using React can be written as\n1 2 3 4 5 6 7 8 9  //Gets root element from DOM const rootElement = document.getElementById(\u0026#34;root\u0026#34;); //Creates a div element for DOM const element = React.createElement(\u0026#34;div\u0026#34;, { className: \u0026#34;container\u0026#34;, childeren: \u0026#34;Hello world\u0026#34;, }); //appends element to root element ReactDOM.render(element, rootElement);   Lets breakdown this code..\n We are getting root element from DOM using id(this didnt change, this is similar to previous code) In the next line we are creating a new DOM element using react\u0026rsquo;s API React.createElement  For that element we are passing HTML element we want to create and properties that we want to set.  Note the children property, It takes the text we want to insert between html tags. Eg: Hello world className property is similar to DOM API it adds a new class to the element.     Once we are done creating element, we are using ReactDOM.render() api to append our elements to the root element of the DOM.  ReactDOM takes two values, elementThatWeWantToAppend elementThatGetsValueAppendedTo syntax: ReactDOM.render(elementThatWeWantToAppend, elementThatGetsValueAppendedTo);    Btw, did you notice how similar React APIs and DOM APIs are ?\nNesting Elements One thing i didnt tell you earlier is that we can set the chidren property as an array of elements.\nSo our hello world example can also be written as..\n1 2 3 4 5 6 7 8  React.createElement(\u0026#34;div\u0026#34;, { className: \u0026#34;container\u0026#34;, children: \u0026#34;Hello world\u0026#34; }); //is same as  React.createElement(\u0026#34;div\u0026#34;, { className: \u0026#34;container\u0026#34;, children: [\u0026#34;Hello\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;world\u0026#34;], });   Now lets generate the below html snippet using react\n1 2 3 4 5 6 7 8  \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;span\u0026gt;Hello\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;World\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;   Using react\n1 2 3 4 5 6 7 8 9  const rootElement = document.getElementById(\u0026#34;root\u0026#34;); const helloEle = React.createElement(\u0026#34;span\u0026#34;, {}, \u0026#34;Hello\u0026#34;); const worldEle = React.createElement(\u0026#34;span\u0026#34;, {}, \u0026#34;World\u0026#34;); const element = React.createElement(\u0026#34;div\u0026#34;, { className: \u0026#34;container\u0026#34;, children: [helloEle, \u0026#34; \u0026#34;, worldEle], });   children property is a special kind of property, you can have one element as argument or if you want multiple elements then you can provide with additional number of arguments.\nThe above code can also be written as..\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  const rootElement = document.getElementById(\u0026#34;root\u0026#34;); const helloEle = React.createElement(\u0026#34;span\u0026#34;, {}, \u0026#34;Hello\u0026#34;); //instead of putting empty object, you can also put null const helloEle = React.createElement(\u0026#34;span\u0026#34;, null, \u0026#34;Hello\u0026#34;); const worldEle = React.createElement(\u0026#34;span\u0026#34;, {}, \u0026#34;World\u0026#34;); //or you can just create like this const worldEle = React.createElement(\u0026#34;span\u0026#34;, { children: \u0026#34;world\u0026#34; }); const element = React.createElement( \u0026#34;div\u0026#34;, { className: \u0026#34;container\u0026#34;, }, helloEle, \u0026#34; \u0026#34;, worldEle ); console.log(element); ReactDOM.render(element, rootElement);   That\u0026rsquo;s all for now.\nSo now you saw how difficult it becomes to write the code when you use RAW APIs. In the next article we will understand a simpler way to create elements using JSX (whose syntax looks similar to HTML) and understand how it works behind the scenes.\nUntil next time 👋, Happy learning 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"Intro to Raw React APIs","id":24,"section":"posts","tags":["javascript","react"],"title":"React Fundamentals: Intro to Raw React APIs","uri":"https://gsavitha.in/posts/intro-to-raw-react-apis/"},{"content":"Before getting started you need to know..\n How Asynchronous code works in JS What are promises and how they work  Introduction To work with async functions, we need to use callbacks or promises. Async and await makes our work easier and cleaner with promises and create synchronous looking asynchronous code\nThe async and await keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function resolveAfter2Seconds() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#34;resolved\u0026#34;); }, 2000); }); } async function asyncCall() { console.log(\u0026#34;calling\u0026#34;); const result = await resolveAfter2Seconds(); console.log(result); // expected output: \u0026#39;resolved\u0026#39; } asyncCall();   async  Async functions always return a promise If the function returns a value, the promise will be resolved with that value. If the function throws an exception, the promise will be rejected  Lets look at few examples..\n1 2 3 4 5 6 7 8 9  async function hello() { return \u0026#34;hello world\u0026#34;; } hello(); // Promise {resolved :\u0026#39;hello world\u0026#39;}  async function ohNo() { throw new Error(\u0026#34;oh no!\u0026#34;); ohNo(); //Promise {rejected : Error: \u0026#39;oh no!\u0026#39;} }   1 2 3 4 5 6 7  async function greet() { return \u0026#34;Hello!!\u0026#34;; } greet().then((val) =\u0026gt; { console.log(\u0026#34;Promise is resolved with :\u0026#34;, val); });   1 2 3 4 5 6 7 8 9 10 11 12 13 14  //throw an exception or an error to reject a promise async function add(x, y) { if (typeof x !== \u0026#34;number\u0026#34; || typeof y !== \u0026#34;number\u0026#34;) throw \u0026#34;X and Y must be numbers\u0026#34;; return x + y; } add(\u0026#34;e\u0026#34;, \u0026#34;r\u0026#34;) .then((val) =\u0026gt; { console.log(\u0026#34;Promise resolved with\u0026#34;, val); }) .catch((err) =\u0026gt; { console.log(\u0026#34;Promise rejected with\u0026#34;, err); });   If we had to write the above code with promises, it would look like..\n1 2 3 4 5 6 7  function add(x, y) { return new Promise((resolve, reject) =\u0026gt; { if (typeof x !== \u0026#34;number\u0026#34; || typeof y !== \u0026#34;number\u0026#34;) reject(\u0026#34;X and Y must be numbers\u0026#34;); }); resolve(x + y); }   await  We can only use the await keyword inside of function declared as async. await will pause the execution of the function, waiting for the promise to be resolved. Without having to use .next() we can run code after an async operation  Before await was introduced, we had to manually resolve a promise\n1 2 3 4 5 6 7 8 9  //get the list of planets  function getPlanets() { return axios.get(\u0026#34;https://swapi.dev/api/planets/\u0026#34;); } getPlanets.then((res) =\u0026gt; { console.log(\u0026#34;Planets data\u0026#34;, res.data); });   With await:\n1 2 3 4  async function getPlanets() { const res = await axios.get(\u0026#34;https://swapi.dev/api/planets/\u0026#34;); //await returns a promise capture it  console.log(res.data); }    By putting await infront of a request, js will wait until the promise is resolved, it will not move on.\n Error handling in async Functions Lets say we had a network failure or if the URL is invalid, promise gets rejected, and we are not catching it.\nWe have a couple of options to resolve this\n chain .catch() to our method Nest our logic which you think might throw an error in try and catch block.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //1st way async function getPlanets() { const res = await axios.get(\u0026#34;https://swapi.dev/api/planets/jknkl\u0026#34;); //await returns a promise capture it  console.log(res.data); } getPlanets().catch((err) =\u0026gt; { console.log(\u0026#34;In catch!\u0026#34;, err); }); //2nd way async function getPlanets() { try { const res = await axios.get(\u0026#34;https://swapi.dev/api/planets/jknkl\u0026#34;); console.log(res.data); } catch (error) { console.log(\u0026#34;In catch!\u0026#34;, error); } }   We get the same behaviour, but these two are technically different.\n Using 1st way, we can catch multiple functions that are returning promises and .catch() will run for any of the reason when promise gets rejected . Using 2nd way, catches errors only within that async function.  Using .catch() is more like a backup to catch multiple potential errors. try and catch is more specific to what we\u0026rsquo;re trying to do and we can be more detailed how we handle it.\nMultiple awaits Without using .then() \u0026rsquo;s from our previous code from promises section. lets refactor the code using await.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const moveX = (element, amount, delay) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const bodyBoundary = document.body.clientWidth; const elRight = element.getBoundingClientRect().right; const currLeft = element.getBoundingClientRect().left; if (elRight + amount \u0026gt; bodyBoundary) { reject(bodyBoundary, elRight, amount); } else { element.style.transform = `translateX(${currLeft + amount}px)`; resolve(); } }, delay); }); }; const btn = document.querySelector(\u0026#34;button\u0026#34;); async function animateRight(el) { await moveX(el, 100, 1000); //we can await this function since it returns a promise  moveX(el, 100, 1000); }   Once we hit the end lets animate back to left\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //move a little more right async function animateRight(el, amt) { await moveX(el, amt, 1000); //we can await this function since it returns a promise  await moveX(el, amt, 1000); await moveX(el, amt, 1000); await moveX(el, amt, 1000); await moveX(el, amt, 1000); await moveX(el, amt, 1000); await moveX(el, amt, 1000); } animateRight(btn, 100).catch((err) =\u0026gt; { console.log(\u0026#34;All done\u0026#34;); animateRight(btn, -100); });   Parallel vs Sequential requests Sequential Requests :\n1 2 3 4 5 6 7 8 9  async function get3Pokemon() { const poke1 = await axios.get(\u0026#34;https://pokeapi.co/api/v2/pokemon/1\u0026#34;); const poke2 = await axios.get(\u0026#34;https://pokeapi.co/api/v2/pokemon/2\u0026#34;); const poke3 = await axios.get(\u0026#34;https://pokeapi.co/api/v2/pokemon/3\u0026#34;); console.log(poke1.data); console.log(poke2.data); console.log(poke3.data); } get3Pokemon();   Here poke1 is a response from promise.\nIts important to know all these functions are happening in sequence. poke1 executes and returns first then poke2 and next poke3. (We dont need these to be in sequence, because these aint depending on each other.)\nParallel Requests: We are not going to await while sending off these requests\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  async function get3Pokemon() { // all requests are sent at same time  const prom1 = axios.get(\u0026#34;https://pokeapi.co/api/v2/pokemon/1\u0026#34;); const prom2 = axios.get(\u0026#34;https://pokeapi.co/api/v2/pokemon/2\u0026#34;); const prom3 = axios.get(\u0026#34;https://pokeapi.co/api/v2/pokemon/3\u0026#34;); console.log(prom1); //pending -\u0026gt; probably all 3 are pending infact  const poke1 = await prom1; //await the response that comes back  const poke2 = await prom2; const poke3 = await prom3; console.log(prom1); //resolved  console.log(poke1.data); console.log(poke2.data); console.log(poke3.data); } get3Pokemon();   Here poke1 is a promise. All promises are ran first, initially they all are in pending state and all requests are sent at once over here. We are not waiting for one to complete and get resolved. first we request all at once, then we reolve them later.\nTo get a clear understanding try the below code in your console for a visual representation\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  //SEQUENTIAL REQUESTS function changeBodyColor(color, delay) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { document.body.style.backgroundColor = color; resolve(); }, delay); }); } async function lightShow() { await changeBodyColor(\u0026#34;teal\u0026#34;, 1000); await changeBodyColor(\u0026#34;pink\u0026#34;, 1000); await changeBodyColor(\u0026#34;indigo\u0026#34;, 1000); await changeBodyColor(\u0026#34;violet\u0026#34;, 1000); } lightShow(); //teal, pink, indigo, violet colors are shown one after the other with 1 sec gap -\u0026gt; total 4+ sec  //PARALLEL REQUESTS async function lightShow() { const p1 = changeBodyColor(\u0026#34;teal\u0026#34;, 1000); const p2 = changeBodyColor(\u0026#34;pink\u0026#34;, 1000); const p3 = changeBodyColor(\u0026#34;indigo\u0026#34;, 1000); const p4 = changeBodyColor(\u0026#34;violet\u0026#34;, 1000); await p1; await p2; await p3; await p4; } //1sec.. we go straight to violet, we dont see those pauses along the way -\u0026gt; total 1 sec    Tip:\nIf you dont need your requests in sequence, do it in parallel\n Promise.all Refactoring with promise.all.\n The Promise.all() method takes an iterable of promises as an input, and returns a single Promise that resolves to an array of the results of the input promises. This returned promise will resolve when all of the input\u0026rsquo;s promises have resolved, or if the input iterable contains no promises. It rejects immediately upon any of the input promises rejecting or non-promises throwing an error, and will reject with this first rejection message / error. - MDN\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  async function get3Pokemon() { const prom1 = axios.get(\u0026#34;https://pokeapi.co/api/v2/pokemon/1\u0026#34;); const prom2 = axios.get(\u0026#34;https://pokeapi.co/api/v2/pokemon/2\u0026#34;); const prom3 = axios.get(\u0026#34;https://pokeapi.co/api/v2/pokemon/3\u0026#34;); const results = await Promise.all([prom1, prom2, prom3]); //this line will only run when all of the promises are resolved  printPokemon(results); } function printPokemon(results) { for (let pokemon of results) { console.log(pokemon.data.name); } } get3Pokemon();   Checkout MDN: Promise.all\nThat\u0026rsquo;s all folks. Until next time 👋 , Happy learning 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"A syntactical sugar to promises","id":25,"section":"posts","tags":["javascript","async"],"title":"Async and Await","uri":"https://gsavitha.in/posts/async-await/"},{"content":"Hey there 👋,\nBefore diving into the world of asynchronous events, lets first understand what happens when you execute a function? where do they get stored in memory? How does the interpreter knows the order of the functions to be executed? Can we run multiple functions at a time?\nWithout making any further delay, lets get started\u0026hellip;\nThe call stack  The mechanism JS interpreter uses to keep track of its place in a script that calls multiple functions.\n Ever wondered how JS \u0026ldquo;knows\u0026rdquo; what function is currently being executed and what functions need to be called next? with the help of call stack.\nHow does it work?  When a script calls a function, interpreter adds it to the call stack and then starts carrying out the function. Any functions that are called by that function are added to the call stack further up, and run where their calls are reached. When the current function is finished, interpreter takes it off the stack and resumes execution where it left off in the last code listing.  JS is single threaded At any given point in time, a single JS thread is running atmost one line of JS code. Its not multi tasking, it does one thing at a time.\nUser may not be able to do another task until one is completed.\n1 2 3  console.log(\u0026#34;first\u0026#34;); alert(\u0026#34;hi\u0026#34;); console.log(\u0026#34;second\u0026#34;);   You wont get output of 2nd console.log until alert hi is closed.When we try to access data from a database or an api or trying to save something or to set timer, we cant let user to keep on waiting until we get the data. Don\u0026rsquo;t we have any workaround for this? We do Asynchronous callbacks.\nHow Asynchronous callbacks work? Pass a callback function for the processes that take time and those functions will be executed at the appropriate time.\nSet timer for 3 seconds.\n1 2 3 4 5  console.log(\u0026#34;first\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;I print after 3 sec\u0026#34;); }, 3000); console.log(\u0026#34;second\u0026#34;);   But how does JS know to set a timer for 3 seconds if it can only do 1 thing at a time? how does it remember to wait for 3 seconds and call that function after 3 sec?\nThe trick here is The browser does the work. JS is not same as our browser, it is a language that is implemented in our browser. Generally browsers like chrome, safari and IE are written in a different programming language (C++ here for those 3).\nBrowser itself is capable of doing certain tasks, where JS sucks at or things that take time are handed off to the browser.\n Note: JS is not keeping track of timer , it is not sending an API request. The browser handles that\n But how does browser do that? Browsers come with web API that are able to handle certain tasks in the background(like making requests or setTimeOut). The JS call stack recognizes these web API functions and passes them off to the browser to take care. Once the browser finishes those tasks they return and are pushed onto the stack as callback.\n1 2 3 4 5 6 7  console.log(\u0026#34;first\u0026#34;); // ran by javascript //js passes entire setTimeOut to be run by C++ or the language in which browser is implemented in. //and continues executing next line of code setTimeout(function () { console.log(\u0026#34;I print after 3 sec\u0026#34;); }, 3000); console.log(\u0026#34;second\u0026#34;); // ran by javascript   Once the browser finishes of setTimeOut it asks JS to run that callback . It places that callback on the call stack so that JS knows to run that function. JS doesnt keep the time. Same thing with making request, JS doesnt make the request itself the browser and the web api do.\nConcurrency and the event loop The reason why we can do things concurrently is that browser is more than just runtime.\nThis diagram basically looks identical to Node\u0026rsquo;s architecture, instead of Web apis we have c++ apis(because browser is implemented in c++) and the threading being hidden from us is done by c++.\nThe setTimeOut api is provided by browser. It doesnt live in V8 source, its the extra we are getting in the environment we are running the javascript\nNow that setTimeOut is out of call stack we can execute other lines of code.\nThe timer in web api cant just start modifying our code, it cant chuck stuff on to the stack when its ready if it did, it would randomly appear in middle of the queue. So any of the webapis pushes the callbacks onto task queue when its done.\nEvent loop Event loop has the one simple job. Its job is to look at the stack and look at the task queue. If the stack is empty,it takes the first thing on the queue and pushes it onto the stack which effectively runs it.\n Note:\nEvent loop pushes the callback onto stack, only when its empty.\n  The above used images above are taken from this video   Note:\nAJAX requests, DOM, Event Listeners, setTimeOut etc are handled by Web APIs. Here are the list of web apis\n  Also check out video on event loops for more info.\n  To visualize how things work in the background check this tool\n Now we know why callbacks are so important in javascript. We pass a callback in to certain functions that the browser takes over.\nBut callbacks are not perfect, they can get messy very quickly.\nIn the below example, you dont need to worry what transform and translate are. Just imagine there is a button on the page, every time the below function executes, it moves right by 100px\nhtml js  1 2 3 4  \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;Move me\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt;     1 2 3 4  const btn = document.querySelector(\u0026#34;button\u0026#34;); setTimeout(() =\u0026gt; { btn.style.transform = `translateX(100px)`; //moves the button to the right by 100px }, 1000);       'use strict'; var containerId = JSON.parse(\"\\\"69a9698fa57514c4\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Now lets say i want to move this button 5 levels deeper for every 1 sec. We need to nest this function .(move 5 times towards right)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  setTimeout(() =\u0026gt; { btn.style.transform = `translateX(100px)`; setTimeout(() =\u0026gt; { btn.style.transform = `translateX(200px)`; setTimeout(() =\u0026gt; { btn.style.transform = `translateX(300px)`; setTimeout(() =\u0026gt; { btn.style.transform = `translateX(400px)`; setTimeout(() =\u0026gt; { btn.style.transform = `translateX(500px)`; }, 1000); }, 1000); }, 1000); }, 1000); }, 1000);   Let\u0026rsquo;s refactor this\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const moveX = (element, amount, delay, callback) =\u0026gt; { setTimeout(() =\u0026gt; { element.style.tranform = `translateX(${amount}px)`; if (callback) callback(); }, delay); }; moveX(btn, 100, 1000, () =\u0026gt; { moveX(btn, 200, 1000, () =\u0026gt; { moveX(btn, 300, 1000, () =\u0026gt; { moveX(btn, 400, 1000, () =\u0026gt; { moveX(btn, 500, 1000); }); }); }); });   Even this doesnt look much scarier. Lets throw another callback if we move off the screen. previously we had only one branch going down(moveX-\u0026gt; moveX -\u0026gt; moveX \u0026hellip;).\nNow we have two call backs for one function. Often this pattern is used we send a http request, if it is success then run one callback, if its a failure run another.\nit would look like this..\n1 2 3 4 5 6 7 8  request( () =\u0026gt; { //onSuccess  }, () =\u0026gt; { //on failure  } );   The callback hell 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  const btn = document.querySelector(\u0026#34;button\u0026#34;); //This function moves an element \u0026#34;amount\u0026#34; number of pixels after a delay. //If the element will stay on screen, we move the element and call the onSuccess callback function //If the element will move off screen, we do not move the element and instead call the onFailure callback const moveX = (element, amount, delay, onSuccess, onFailure) =\u0026gt; { setTimeout(() =\u0026gt; { const bodyBoundary = document.body.clientWidth; const elRight = element.getBoundingClientRect().right; const currLeft = element.getBoundingClientRect().left; if (elRight + amount \u0026gt; bodyBoundary) { onFailure(); } else { element.style.transform = `translateX(${currLeft + amount}px)`; onSuccess(); } }, delay); }; // LOOK AT THIS UGLY MESS! moveX( btn, 300, 1000, () =\u0026gt; { //success callback  moveX( btn, 300, 1000, () =\u0026gt; { //success callback  moveX( btn, 300, 1000, () =\u0026gt; { //success callback  moveX( btn, 300, 1000, () =\u0026gt; { //success callback  moveX( btn, 300, 1000, () =\u0026gt; { //success callback  alert(\u0026#34;YOU HAVE A WIDE SCREEN!\u0026#34;); }, () =\u0026gt; { //failure callback  alert(\u0026#34;CANNOT MOVE FURTHER!\u0026#34;); } ); }, () =\u0026gt; { //failure callback  alert(\u0026#34;CANNOT MOVE FURTHER!\u0026#34;); } ); }, () =\u0026gt; { //failure callback  alert(\u0026#34;CANNOT MOVE FURTHER!\u0026#34;); } ); }, () =\u0026gt; { //failure callback  alert(\u0026#34;CANNOT MOVE FURTHER!\u0026#34;); } ); }, () =\u0026gt; { //failure callback  alert(\u0026#34;CANNOT MOVE FURTHER!\u0026#34;); } );   This is where promises come in. Promises allow us to rewrite a function like this without doing all of this crazy nesting. It makes the code more easier to read\nIf you want to know more about promises, refer Promises Explained.\nHope that was not convoluted and crazy. Until next time, Happy learning 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"Explains how asynchronous code works in javascript","id":26,"section":"posts","tags":["javascript","async"],"title":"Asynchronous Code in Javascript","uri":"https://gsavitha.in/posts/async-code-in-js/"},{"content":"Promises are one of the important concepts in javascript one should be familiar with.\nPre-requisite: Before going into promises you need to understand what is asynchronous code, how it works, what are callbacks and why are promises introduced.\nCheckout Asynchronous Code in JavaScript\nOnce you understand that, without making any further delay lets get started..\nIntro to Promises  A promise is an object representing the eventual completion(usually which takes time) or failure of an asynchronous operation.\n Promises allow us to write an asynchronous code that is much easier to read and understand. Its much flatter, its not so nested.\nIf you have checked out this post you might be familiar with the Callback example we used.\nThe same code after using promises, looks like this\u0026hellip;\n1 2 3 4 5 6 7 8 9  moveXPromise(btn, 100, 000) .then(() =\u0026gt; moveXPromise(btn, 100, 1000)) .then(() =\u0026gt; moveXPromise(btn, 200, 1000)) .then(() =\u0026gt; moveXPromise(btn, 300, 1000)) .then(() =\u0026gt; moveXPromise(btn, 500, 1000)) .then(() =\u0026gt; moveXPromise(btn, 500, 1000)) .catch((position) =\u0026gt; { alert(\u0026#34;Cannot move further\u0026#34;); });   I remember promises as A pattern to write async code.\nWhen we work with promises there are only 2 different things we need to understand\n How you create a promise. How you could create a function that returns a promise. How you consume and interact with the promises (which we do all the time, even if we are not writing promises ourselves. we might make a req from a library or using a library like axioms )  So promise is a way of promising a value that you may not have at the moment. Its a guarantee or supposed guarantee of an eventual value.\nIf you are making a HTTP request it could take time and may never return the value. It might be a failure or success and you might get some data backfrom an API but it takes time. So the object that is returned in the meantime is a promise and we attach a callback to it.\n Note:\nA promise is a returned object to which you attach callbacks, instead of passing callbacks into a function.\n Creating a Promise Syntax:\n1  const createPromise = new Promise((resolve, reject) =\u0026gt; {});   resolve and reject are actually functions. At any point inside of the function, if we call resolve , promise will be resolved. If we call reject, promise will be rejected\n1 2 3  const willGetYouADog = new Promise((resolve, reject) =\u0026gt; {}); /*[[PromiseStatus]] : \u0026#34;pending\u0026#34; [[PromiseValue]] : undefined*/    pending status is what we see frequently when a promise is first started   Note:\nIf you dont resolve or reject a promise, its status will be pending and its value will be undefined\nPromiseStatus : \u0026ldquo;pending\u0026rdquo;\nPromiseValue : undefined\n If you simply call reject\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const willGetYouADog = new Promise((resolve, reject) =\u0026gt; { reject(); }); //We get an error that we didnt catch (in console), Error : Uncaught in promise //[[Promise Status]] : rejected //[[Promise Value]] : undefined  // Instead if we resolve:  const willGetYouADog = new Promise((resolve, reject) =\u0026gt; { resolve(); }); //No error //[[Promise Status]] : resolved //[[Promise Value]] : undefined   Lets write a logic for a promise, which randomly resolves or rejects a promise.\n1 2 3 4 5  const willGetYouADog = new Promise((resolve, reject) =\u0026gt; { const rand = Math.random(); if (rand \u0026lt; 0.5) resolve(); else reject(); });   This is the first part of how we create a promise. The extremely important part is how we interact with the promise when it is rejected and when it is resolved. This is where we use .then() \u0026amp; .catch() methods.\nInteracting with promises When a promise is resolved it automatically runs .then() and when a promise is rejected it automatically runs .catch()\n1 2 3 4 5 6 7 8 9 10 11  const willGetYouADog = new Promise((resolve, reject) =\u0026gt; { const rand = Math.random(); if (rand \u0026lt; 0.5) resolve(); else reject(); }); willGetYouADog.then(() =\u0026gt; { console.log(\u0026#34;Yay we got a dog!\u0026#34;); }); willGetYouADog.catch(() =\u0026gt; { console.log(\u0026#34;No dog :(\u0026#34;); });   If we do neither, status remains pending until its resolved or rejected\nReturning Promises from functions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  const makeADogPromise = () =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const rand = Math.random(); if (rand \u0026lt; 0.5) resolve(); else reject(); }, 5000); }); }; //we can actually chain the methods instead of creating another promise by calling makeADogPromise.catch() // if we create 2 seperate promises we may not resolve or we may not reject. We can have different values //but instead if we chain, we get around that problem // we will not be wasting any extra space by creating a new variable //(d = make .. d.then() , d.catch()) by chaining and also we wont be creating an extra reference to a promise again. //only one of the other will run if we do chaining makeADogPromise .then(() =\u0026gt; { console.log(\u0026#34;Yay we got a dog!\u0026#34;); }) .catch(() =\u0026gt; { console.log(\u0026#34;No dog :(\u0026#34;); });   Returning a promise from functions is a very common pattern.\nExample:\n1  axios.get(\u0026#34;/reddit.com\u0026#34;).then().catch();   Axios is returning a promise by executing the get() function\nResolving or rejecting with values When you resolve or reject a promise you can reject or resolve with a value and you have access to that value in callback that you pass into then or catch\nAn example to check if a url exists in the object and pass the data and status code based on the user\u0026rsquo;s request\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  const fakeRequest = (url) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const pages = { \u0026#34;/users\u0026#34;: [ { id: 1, username: \u0026#34;bob\u0026#34; }, { id: 5, username: \u0026#34;clarke\u0026#34; }, ], \u0026#34;/about\u0026#34;: \u0026#34;This is about page\u0026#34;, }; const data = pages[url]; if (data) resolve({ status: 200, data: data }); else reject({ status: 404 }); }, 3000); }); }; //runs then() fakeRequest(\u0026#34;/users\u0026#34;) .then((res) =\u0026gt; { console.log(\u0026#34;Status code\u0026#34;, res.status); console.log(\u0026#34;Data\u0026#34;, res.data); console.log(\u0026#34;Request worked\u0026#34;); }) .catch((res) =\u0026gt; { console.log(res.status); console.log(\u0026#34;Request failed\u0026#34;); }); // runs catch(), coz we dont have /dogs url fakeRequest(\u0026#34;/dogs\u0026#34;) .then((res) =\u0026gt; { console.log(\u0026#34;Status code\u0026#34;, res.status); console.log(\u0026#34;Data\u0026#34;, res.data); console.log(\u0026#34;Request worked\u0026#34;); }) .catch((res) =\u0026gt; { console.log(res.status); console.log(\u0026#34;Request failed\u0026#34;); });   Promise Chaining js js  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  const fakeRequest = (url) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const pages = { \u0026#34;/users\u0026#34;: [ { id: 1, username: \u0026#34;Bilbo\u0026#34; }, { id: 5, username: \u0026#34;Esmerelda\u0026#34; }, ], \u0026#34;/users/1\u0026#34;: { id: 1, username: \u0026#34;Bilbo\u0026#34;, upvotes: 360, city: \u0026#34;Lisbon\u0026#34;, topPostId: 454321, }, \u0026#34;/users/5\u0026#34;: { id: 5, username: \u0026#34;Esmerelda\u0026#34;, upvotes: 571, city: \u0026#34;Honolulu\u0026#34;, }, \u0026#34;/posts/454321\u0026#34;: { id: 454321, title: \u0026#34;Ladies \u0026amp; Gentlemen, may I introduce my pet pig, Hamlet\u0026#34;, }, \u0026#34;/about\u0026#34;: \u0026#34;This is the about page!\u0026#34;, }; const data = pages[url]; if (data) { resolve({ status: 200, data }); //resolve with a value!  } else { reject({ status: 404 }); //reject with a value!  } }, 1000); }); };     1 2 3 4 5 6 7 8 9 10 11 12 13  fakeRequest(\u0026#34;/users\u0026#34;).then((res) =\u0026gt; { const id = res.data[0].id; //make another request with id, we cant do do it outside of this scope, coz we dont have access to id outside  //nest it here  fakeRequest(`/users/${id}`).then((res) =\u0026gt; { //access the post  const postId = res.data.topPostId; //make a request to that post -\u0026gt; this is a 3rd request that is dependent upon 2nd and 2nd is dependent upon 1st  fakeRequest(`/posts/${postId}`).then((res) =\u0026gt; { console.log(res); }); }); });       'use strict'; var containerId = JSON.parse(\"\\\"9228c9f84abe3d1c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  This doesnt look much better than what we saw in callback hell and also we dont have catches yet, if we have catches for each .then() it would look more messier. We have much better way for rewriting all of this\nWhat we can do is in the callback of .then() return a new promise, we can call callback of .then() of next request immediately in the same level, we dont need to nest our .then(). We can continue to chain .then() as long as we return promises in each callback.\nSyntax:\n1 2 3 4 5 6 7 8 9 10  .then(()=\u0026gt;{ return promise; }) .then(()=\u0026gt;{ return promise; }) .then(()=\u0026gt;{ return promise; })    Note:\nThe second .then() runs only if first .then() is resolved, third .then() runs only if second is resolved.\n After nesting\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  fakeRequest(\u0026#34;/users\u0026#34;) .then((res) =\u0026gt; { console.log(res); const id = res.data[0].id; return fakeRequest(`/users/${id}`); }) .then((res) =\u0026gt; { console.log(res); const postId = res.data.topPostId; return fakeRequest(`/posts/${postId}`); }) .then((res) =\u0026gt; { console.log(res); }) .catch((err) =\u0026gt; { console.log(\u0026#34;OH NO!\u0026#34;, err); });   So here is the magical part, We only need one .catch(). If any of the promise is screwed up, the catch will run immediately, we dont need to write catch for each promise. Its like a catch all 🎉\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // ************************************************ // ATTEMPT 2 (deliberate error to illustrate CATCH) // ************************************************ fakeRequest(\u0026#34;/users\u0026#34;) .then((res) =\u0026gt; { console.log(res); const id = res.data[0].id; return fakeRequest(`/useALSKDJrs/${id}`); //INVALID URL, CATCH WILL RUN!  }) .then((res) =\u0026gt; { console.log(res); const postId = res.data.topPostId; return fakeRequest(`/posts/${postId}`); }) .then((res) =\u0026gt; { console.log(res); }) .catch((err) =\u0026gt; { console.log(\u0026#34;OH NO!\u0026#34;, err); });    Note:\nIf we screw up any promise in between, the promises after it wont be executed.\n Here in the above example 1st promise is ran, second is screwed up .. so only resolved output of 1st one is shown\nUsing chaining, we can have multiple asynchronous actions that we want to happen one after the other(not simultaneously).\nExample Let\u0026rsquo;s refactor our previous call back hell example with promises.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  const moveX = (element, amount, delay) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { const bodyBoundary = document.body.clientWidth; const elRight = element.getBoundingClientRect().right; const currLeft = element.getBoundingClientRect().left; if (elRight + amount \u0026gt; bodyBoundary) { reject(bodyBoundary, elRight, amount); } else { element.style.transform = `translateX(${currLeft + amount}px)`; resolve(); } }, delay); }); }; moveX(btn, 300, 1000) .then(() =\u0026gt; { return moveX(btn, 300, 1000); }) .then(() =\u0026gt; { return moveX(btn, 300, 1000); }) .then(() =\u0026gt; { return moveX(btn, 300, 1000); }) .then(() =\u0026gt; { return moveX(btn, 300, 1000); }) .catch(() =\u0026gt; { console.log(\u0026#34;Out of space, cannot move\u0026#34;); });   We can still shorten this up using implicit returns of arrow functions\n1 2 3 4 5 6 7 8 9 10  moveXPromise(btn, 100, 000) .then(() =\u0026gt; moveXPromise(btn, 300, 1000)) .then(() =\u0026gt; moveXPromise(btn, 300, 1000)) .then(() =\u0026gt; moveXPromise(btn, 300, 1000)) .then(() =\u0026gt; moveXPromise(btn, 300, 1000)) .then(() =\u0026gt; moveXPromise(btn, 300, 1000)) .catch(({ bodyBoundary, elRight, amount }) =\u0026gt; { console.log(`Body is ${bodyBoundary}px width`); console.log(`Element is at ${elRight}px, ${amount}px is too large`); });   Is there any other better way other than promises? Checkout Async and Await\nUntil next time 👋, happy learning 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"Promises : A pattern to write async code in JS","id":27,"section":"posts","tags":["javascript","async"],"title":"Promises Explained","uri":"https://gsavitha.in/posts/promises-explained/"},{"content":"Hey, there 👋\nWelcome to the 1st article of the Epic React Series which is based on the workshop EpicReact.dev by Kent C. Dodds\nIn this article lets look at the basics of JS one should know before getting started with React. Feel free to skip the topics you already know.\nLogical operators These operators are also known as short-circuit evaluation operators\nLogical \u0026amp;\u0026amp; (AND)  Let\u0026rsquo;s say you have two expressions x and y 1  x \u0026amp;\u0026amp; y;    This operation will be executed if both x and y are truthy. If either of the expressions is falsy operation wont be executed. This operator is known as short-circuit evaluation operator because, if the first expression or operation x is falsy, operation wont be continued further, and it returns false    Logical || (OR)  Let\u0026rsquo;s say you have two expressions x and y 1  x || y;    This operation is executed if either of the expressions is [truthy]((https://developer.mozilla.org/en-US/docs/Glossary/truthy) Short circuiting happens here as well:  If the first expression evaluates to true, operation wont be continued further and the output is returned as true.      Ternary Operator   This is a shorthand expression of if-else.\nWithout ternary:\n1 2 3 4 5  if (condition) { doSomething(); } else { doSomethingElse(); }   Using ternary:\n1  condition ? doSomething() : doSomethingElse();     If condition is true, evaluate doSomething() else evaluate doSomethingElse()\n  Template Literals   Template literals are like the super power to Strings. You can use multi line strings and interpolate string features in them.\n  This feature is newly introduced in ES6.\n  Lets look at few examples\n1 2 3 4 5  const name = \u0026#34;Savitha\u0026#34;; //without template literals console.log(\u0026#34;Hello, my name is \u0026#34; + name); //with template literals console.log(`Hello, my name is ${name}`);     Not only that, you can also interpolate inline calculations and function calls with in your expression easily.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  const name = \u0026#34;Savitha\u0026#34;; const getRandomIndex = (max) =\u0026gt; Math.floor(Math.random() * Math.floor(max)); const numbers = [1, 3, 5, 7, 9]; const getNum = (index) =\u0026gt; numbers[index]; //without template Literals console.log( \u0026#34;Hello, my name is \u0026#34; + name + \u0026#34;\\n\u0026#34; + \u0026#34;and my Id is\u0026#34; + getNum(getRandomIndex(numbers.length)) ); //using template literals console.log(`Hello, my name is ${name}and my id is ${getNum(getRandomIndex(numbers.length))}`);     Notice that in the last line after ${name} a new line is added ie., it uses multiline feature\n  MDN: Template Literals\n  Shorthand property names   This feature is very common and you see this alot.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const name = \u0026#34;Savitha\u0026#34;; const id = 85; const place = \u0026#34;India\u0026#34;; //Without shorthand property names const userDetails = { name: name, id: id, location: place, }; //using shorthand property  const userDetails = { name, id, place, };     MDN: Object Initializer New Notations\n  Destructuring  Destructuring is one of my favourite features of ES6 Javascript. I love how declarative it is, I always use Arrays and Objects destructuring wherever it is necessary  Object Destructuring   The concept is very simple, with the use of below syntax, we can extract properties of object into variables.\n1 2 3 4 5 6 7 8 9 10 11  const food = { fruit: [\u0026#34;apple\u0026#34;,\u0026#34;banana\u0026#34;,\u0026#34;pineapple\u0026#34;,\u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;], vegetable: [\u0026#34;potato\u0026#34;,\u0026#34;brinjal\u0026#34;,\u0026#34;tomato\u0026#34;, \u0026#34;beans\u0026#34;], }; //without object destructuring; const fruit = food.fruit, const vegetable = food.vegetable; //with object destructuring const { fruit, vegetable } = food; console.log(fruit); console.log(vegetable);     Note: that object properties and destructured variables should have same name\n  In the context of React, object destructuring is frequently used with function parameters.\n1 2 3 4 5 6 7  const info = { name: \u0026#34;Savitha\u0026#34;, id: \u0026#34;React\u0026#34; }; function printInfo({ name, id }) { console.log(name, id); } printInfo(info); const printName = ({ name }) =\u0026gt; console.log(name); printName(info);     In React we use this pattern with props, which are the input for React components.\n1 2 3  function MyReactComponent({ name, age }) { // ... }     Array Destructuring   With the use of below syntax we get the array elements into variables\n1 2 3 4 5 6 7 8 9  const name = [\u0026#34;Savitha\u0026#34;, \u0026#34;G\u0026#34;]; //without destructuring  const firstName = name[0]; const lastName = name[1]; //with destructuring const [firstName, lastName] = name;     Note: the variables are assigned from left tp right of the array, therefore order is maintained.\n1 2 3 4 5 6 7 8 9 10  const [fruit, veggie] = [ \u0026#34;strawberry\u0026#34;, \u0026#34;broccoli\u0026#34;, \u0026#34;pizza\u0026#34;, \u0026#34;taco\u0026#34;, \u0026#34;sandwich\u0026#34;, \u0026#34;burger\u0026#34;, ]; console.log(fruit); // strawberry console.log(veggie); // broccoli     You can also skip few values\n1 2 3 4 5 6 7 8 9 10 11  const [fruit, , pizza, , , burger] = [ \u0026#34;strawberry\u0026#34;, \u0026#34;broccoli\u0026#34;, \u0026#34;pizza\u0026#34;, \u0026#34;taco\u0026#34;, \u0026#34;sandwich\u0026#34;, \u0026#34;burger\u0026#34;, ]; console.log(fruit); // strawberry console.log(pizza); // pizza console.log(burger); // burger     This concept is frequently used with React Hooks.\n  MDN: Destructuring assignment\n  Arrow functions   A function declaration looks like this:\n1 2 3  function sum(a, b) { return a + b; }     A function expression looks like this:\n1 2 3  const sum = function (a, b) { return a + b; };     An arrow function constitutes as the alternative of the above two.\n1 2 3  const sum = (a, b) =\u0026gt; { return a + b; };     If you have only one parameter you can skip () and if you have only return statement as the function body you can skip {} and return statement.\n1  const user = (name) =\u0026gt; console.log(`My name is ${name}`);     If your function doesn\u0026rsquo;t accept any parameters you need to put parantheses.\n1  const user = () =\u0026gt; console.log(`My name is Savitha`);     Only with function declarations can you invoke functions before they have even been defined. This is because function declarations are hoisted, i.e., they are moved to the top of their scope before execution.\n1 2 3 4 5 6 7 8 9 10  console.log(getNameDeclaration()); // \u0026#34;Savitha\u0026#34; console.log(getNameExp()); // ReferenceError: Cannot access \u0026#39;getNameExp\u0026#39; before initialization console.log(getNameArrow()); // ReferenceError: Cannot access \u0026#39;getNameArrow\u0026#39;before initialization function getNameDeclaration() { return \u0026#34;Savitha\u0026#34;; } const getNameExp = () =\u0026gt; { return \u0026#34;Savitha\u0026#34;; }; const getNameArrow = () =\u0026gt; \u0026#34;Savitha\u0026#34;;     Another difference between function declarations/expressions and arrow function expressions is the this keyword. Read this to know more about it\n  Default Parameters   This is another feature which I use alot.\n  Default parameters as the name speaks, whenever we want a function to take default value we use this.\n1 2 3 4 5  const add = (x = 5, y = 4) =\u0026gt; a + b; add(3, 3); //6 add(3); // x = 3, y = default value (4), 3 + 4 = 7 add(); //uses default values of x and y and returns 9     MDN: Default Parameters\n  Rest/Spread operators Spread   Spread operator (...) allows us to expand iterable values into variables\n1 2 3 4  const multiply = (x,y,z) =\u0026gt; return x * y * z const numbers = [1, 2, 3]; console.log(multiply(...numbers)); //output: 6     We can also copy object properties and thus create a new object\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const food = { breakfast: [\u0026#34;cornflakes\u0026#34;, \u0026#34;oats\u0026#34;], lunch: [\u0026#34;burger\u0026#34;, \u0026#34;fries\u0026#34;, \u0026#34;pizza\u0026#34;], }; const foodAndDrinks = { ...food, drinks: [\u0026#34;wine\u0026#34;, \u0026#34;mocktail\u0026#34;, \u0026#34;beer\u0026#34;, \u0026#34;juice\u0026#34;], }; console.log(foodAndDrinks); /* breakfast: [\u0026#34;cornflakes\u0026#34;, \u0026#34;oats\u0026#34;], lunch: [\u0026#34;burger\u0026#34;, \u0026#34;fries\u0026#34;, \u0026#34;pizza\u0026#34;], drinks:[\u0026#34;wine\u0026#34;, \u0026#34;mocktail\u0026#34;, \u0026#34;beer\u0026#34;, \u0026#34;juice\u0026#34;], */     Rest   While the syntax of rest operator (...) looks exactly like spread operator, its functionality is different. With the help of rest operator you can merge a list of elements into an array\n  If you use the operator inside of {} or [], you use object or array spreading, respectively. On the other hand, if you use the operator with the last argument in a function signature, that is the rest parameter.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  //With arrays const numbers = (x, y, ...other) =\u0026gt; { //some other code }; console.log(numbers); // x = 100, y= 200, other =[300,400,500,600] //with objects const userDetails = { name: \u0026#34;Savitha\u0026#34;, id: 85, place: \u0026#34;India\u0026#34;, }; const { name, ...others } = userDetails; console.log(`${name}${others}`); // Savitha {id:85, place: \u0026#34;India\u0026#34;}     Optional Chaining    The optional chaining operator (?.) enables you to read the value of a property located deep within a chain of connected objects without having to check that each reference in the chain is valid - from MDN\n   This is also known as Elvis Operator. Using this we can safely access properties and call functions that may or may not exist. Before optional chaining we used to have a workaround with truthy/falsy values.\n1 2 3 4 5 6 7 8  //before optional chaining const doorNo = user \u0026amp;\u0026amp; user.location \u0026amp;\u0026amp; user.location.streetName \u0026amp;\u0026amp; user.location.streetName.doorNo; //with optional Chaining  const doorNo = user.?location.?streetName.?doorNo;     MDN: Optional Chaining\n  Nullish Coalescing Operator   Nullish coalescing operator is also used for short circuiting. If a given a value is null or undefined you will be using other operand from the expression\n   The nullish coalescing operator (??) is a logical operator that returns its right-hand side operand when its left-hand side operand is null or undefined, and otherwise returns its left-hand side operand. - from MDN\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //before we used to do this a = a || some_default_value; //but this was problematic for falsy values which are valid  //lets say we wanted to do this multiply(undefined, 5); //we used to do it this way const multiply = (a, b) =\u0026gt; { a = a === undefined ? 1 : a; b = b === undefined ? 1 : b; return a * b; }; //with nullish coalescing we can do this now const multiply = (a, b) =\u0026gt; { a = a ?? 1; b = b ?? 1; };     MDN : Nullish Coalescing\n  Array Methods  Mastering array functions is an important skill for React developers. You will come across map() in almost every react application, e.g., to loop over a list of objects and render every single entry within a component.  map   The map() function produces a new array from an existing array by calling this function for each and every element of the array. This function is used to map values in an array to some other values.\n1 2 3  const fruits = [\u0026#34;🍓\u0026#34;, \u0026#34;🥝\u0026#34;, \u0026#34;🍌\u0026#34;, \u0026#34;🍒\u0026#34;]; const moreFruits = fruits.map((f) =\u0026gt; `${f}${f}`); console.log(moreFruits); // [\u0026#34;🍓🍓\u0026#34;, \u0026#34;🥝🥝\u0026#34;, \u0026#34;🍌🍌\u0026#34;, \u0026#34;🍒🍒\u0026#34;]     filter   The filter() function returns a brand new array containing only those elements of original array that pass a provided condition.\n1 2 3 4 5 6 7  const people = [ { name: \u0026#34;Adam\u0026#34;, gender: \u0026#34;male\u0026#34; }, { name: \u0026#34;Alice\u0026#34;, gender: \u0026#34;female\u0026#34; }, { name: \u0026#34;Athena\u0026#34;, gender: \u0026#34;female\u0026#34; }, ]; const women = people.filter((person) =\u0026gt; person.gender === \u0026#34;female\u0026#34;); console.log(women); //{ name: \u0026#34;Alice\u0026#34;, gender: \u0026#34;female\u0026#34; },{ name: \u0026#34;Athena\u0026#34;, gender: \u0026#34;female\u0026#34; },     reduce  The reduce() method as the name sounds, reduces an array of values into a single value. Runs a callback for each and every element. 1 2 3 4 5 6 7 8 9 10 11 12  const nums = [1, 3, 5, 7, 9]; //Imperative or tradtional way let sum = 0; const sumOfArrayElements = (nums) =\u0026gt; { for (let i = 0; i \u0026lt; nums.length; i++) { sum += nums[i]; } return sum; }; //Declarative way or using reduce function const initial = 0; const sum = nums.reduce((total, current) =\u0026gt; total + current, initial);    Note: Using initial is an optional parameter.    find   Returns the first entry that satisfies the given condition.\n1 2 3  const nums = [5, 15, 25, 30, 45]; const found = nums.find((element) =\u0026gt; element \u0026gt; 20); console.log(found); //25     some   Atleast one element in the array should satisfy the condition. Returns true if, in the array, it finds an element that satisfies the condition, else returns false.\n1 2 3  const nums = [1, 2, 3, 4, 5]; const odd = nums.some((element) =\u0026gt; element % 2 !== 0); console.log(odd); //true     every   Every element of the array must satisfy the condition. Returns true if all the elements pass the condition else returns false.\n1 2 3  const nums = [1, 2, 3, 4, 5]; const isBelowLimit = nums.every((element) =\u0026gt; element \u0026lt; 10); console.log(isBelowLimit); //true     sort   Sorts elements of an array in place \u0026amp; returns sorted array.\n  Default sort order is built upon converting element to string, then comparing to their unicode (UTF-16) unit values\n1 2 3 4  const months = [\u0026#34;March\u0026#34;, \u0026#34;Jan\u0026#34;, \u0026#34;Feb\u0026#34;, \u0026#34;Dec\u0026#34;]; months.sort(); //[Dec,Feb,Jan,March] const nums = [1, 30, 4, 21, 100000]; nums.sort(); //[1,100000,21,30,4]   Syntax: arr.sort(compareFn);\n compareFn determines the sort order. If this is omitted arr elements are converted to strings then sorted according to each character unicode.  1 2 3  let num = [4, 12, 5, 1, 3]; num.sort((a, b) =\u0026gt; a - b); //[1,2,3,4,5] num.sort((a, b) =\u0026gt; b - a); //[5,4,3,2,1]     includes  Determines whether an array includes a certain value among its entries, returns true if an element is included, else returns false\nSyntax: array.includes(element) 1 2 3  const numbers = [1, 3, 5]; values.includes(3); // true values.includes(2); // false     splice   Changes the content of an array by replacing or removing existing elements and / or adding new elements in place.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const months = [\u0026#34;Jan\u0026#34;, \u0026#34;March\u0026#34;, \u0026#34;April\u0026#34;, \u0026#34;June\u0026#34;]; //Add an item to array months.splice(1, 0, \u0026#34;Feb\u0026#34;); //[Jan,Feb,March,April,June] -\u0026gt; RT :[]  //Replace item in array  //replace 1 item at index 4 with the 3rd param months.splice(4, 1, \u0026#34;May\u0026#34;); //[Jan,Feb,March,April,May] -\u0026gt; RT: deleted value -\u0026gt; June  //Delete items let arrDeletedItems = arr.splice(start,deleteCount[,item1[,item2]...]) //start - \u0026gt; index at where to start (if its -ve start from end) //deleteCount -\u0026gt; an integer indicating how many elements to be deleted from `start`  //RT : An array containing deleted items, if no items are deleted an empty array is returned. deleted ele if only one is removed.  months.splice(0,2) //RT: Jan,Feb . arr: [March, April, May]      slice   Returns a shallow copy of portion of an array into new array object selected from begin to end (non inclusive)\n1 2 3 4 5 6 7 8  const num = [1, 2, 3, 4, 5]; num.slice(2); //[3,4,5] num.slice(2, 4); //[3,4] -\u0026gt; 4th pos is not included num.slice(1, 5); //[2,3,4,5] num.slice(-3); //[3,4,5] num.slice(-3, -1); //[3,4] -\u0026gt; go 3 elements back \u0026amp; 1 ele forward. //copy an entire arr num.slice(); //[1,2,3,4,5]     Default Exports vs Named exports  While working with react you will often come across exports and imports, so it is very important to know how this works. Here\u0026rsquo;s a good explanation on Module exporting and importing  Promises and async/await  Promises are the important concept to understand the asynchronous events in the code. These are also used quite often in React. I recommend you to check these resources.  How Asynchronous code works in JS What are promises and how they work Async and Await    Basic DOM APIs   If you ever came across document.getElementById or createElement etc,. you know these are used to modify the DOM elements. Its good to have a knowledge of DOM APIs to understand similiraties and differences between DOM API and react APIs.\n  MDN Docs are best place to learn this\n  Thats all for now. In the next article we\u0026rsquo;ll dive into Raw React APIs to understand the underlying structure of React code.\nUntil next time, Happy learning! 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"These are the JS basics you should be familiar with before getting started with react","id":28,"section":"posts","tags":["javascript","react"],"title":"JS fundamentals for  React","uri":"https://gsavitha.in/posts/js-fundamentals-for-react/"},{"content":"Hello world 👋\nToday I decided to start a new series on react based on Kent C. Dodds\u0026rsquo;s EpicReact.dev workshop. While I go through the content of this workshop, I decided to share the knowledge I gain from it. Hope you enjoy this journey with me :)\nThe content of this workshop is self-paced and it is open source. But I recommended you to buy the course if you are a visual learner.\nIn this article you can find all the blogposts I will be writing as a part of this journey. Feel free to skip if you are familiar with a particular topic.\nReact fundamentals  JS fundamentals for React Intro to raw React APIs Understanding JSX   If you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"Introduction to the series ","id":29,"section":"posts","tags":["javascript","react"],"title":"Epic React Series: Introduction","uri":"https://gsavitha.in/posts/epic-react-intro/"},{"content":"Recently came across an interesting code snippet from github gists.\n1 2 3 4 5 6 7 8  setInterval(() =\u0026gt; { for (const Button of document.querySelectorAll( \u0026#39;div[aria-label=\u0026#34;Action options\u0026#34;]\u0026#39; )) { Button.click(); document.querySelector(\u0026#39;div[role=\u0026#34;menuitem\u0026#34;]\u0026#39;).click(); } }, 1000);   Visit the below url and dont forget to replace with your FB username or userid.\nhttps://www.facebook.com/{your_id_or_username}/allactivity/?category_key=LIKEDPOSTS\u0026amp;filter_hidden=ALL\u0026amp;filter_privacy=NONE\nYou can choose filter to choose year or month.\nOnce you are done with this, open console on your webpage (cmd+shift+J on mac or ctrl+shift+I on windows or linux) or just right click on the webpage choose Inspect Element then select Console and just paste the above snippet and hit Enter.\nBased upon your activity history it may take some time or it may throw an API limit Error. Nevertheless, you can try again later may be after a day.\nNow go and enjoy some privacy 😄 🎉\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"Remove your facebook likes by using this snippet ","id":30,"section":"posts","tags":["gist","javascript","security","scripts"],"title":"Remove All Your Facebook Likes","uri":"https://gsavitha.in/posts/remove-all-facebook-likes/"},{"content":"Most of the web apps these days are having 90% of front end and only 10% of the backend. As the application grows bigger and bigger having a monolithic approach on front end doesn\u0026rsquo;t work. There needs to be a way to break this approach into smaller modules that can work independently.\nMicro Frontends - A micro service approach to front end development.\nWhat does it mean? Micro Frontends are loosely coupled components of UI that are developed by applying micro services principles on frontend.\n Writing Micro frontends is more of an architectural design \u0026amp; development rather than being a technology.\n How does it help? Applying microservices on frontend gives complete freedom to the developers on picking their desired tech stack to develop a service. Not only that, since they are loosely coupled, fault isolation is provided as well.\nMicrofrontends vs Monolithic architecture Despite of having microservices in the backend, a seperate team is required to handle the front end development if you have a monolithic architecture.\n With the micro frontends approach, we split our application into vertical blocks. Where each block goes from end to end from UI to database.\nUsing this micro frontends approach, each team will have an independence to build their own components in their desired tech stack. Later, integrating all these independent components helps us in forming a Complete UI application and also prevents a need to have a dedicated centralised UI team.\n Example - an e-commerce application I took this example because micro frontends in most popular with the e-commerce websites.\nAlright, let us consider an online gaming store as an example.\nOur website has several UI components, some of the key feature components are:\n Search Component: This component helps the users in searching based on the words they enter. Game Category Component: This component helps the users in displaying the games by filtering them based on the given category (price, new arrivals, popular, season\u0026rsquo;s best, highest paid etc) Add to cart and Checkout component: This component helps the users in adding items to cart and proceed with filling the details before the payment. Payment Component: This component helps the users in facilitating different modes of payments.  Every component is powered by a dedicated microservice running behind the scenes. A dedicated full stack teams are assigned to manage and develop individual components.\n Can I use this in my application? It may sound delightful to go forward with the micro frontends approach but it only fits for medium to large scale applications, for simple use cases this approach is not that advantageous. Rather it will make things more complex.\nIf we use multiple technologies for a simple use case, not only it becomes cumbersome but also brings lots of architectural, compatability, performance and maintainance complexities.\nWith micro frontends, we also need to write additional logic to club all the components together.\nSo, there are always trade-offs involved. There is no silver bullet.\nHow do I integrate? So, once we are done with having different micro frontends, how can we integrate them all together to have a fully functional website?\nWe can do it in 2 ways:\n Integrating micro frontends on client Integrating micro frontends on server  This concept is pretty similar to client side \u0026amp; server side rendering. In this case we just need to write additional logic to integrate different UI components.\nClient side integration A naive approach is to have micro frontends with unique links, whenever a user clicks a link they will be navigating to micro frontend.\n Lets say you have hosted your checkout component on Google Cloud and Payments on AWS. If you integrate via basic links, when you navigate from checkout page to payments page, the address in the browser will be visible to the end user (when it changes from GCP\u0026rsquo;s URL to AWS\u0026rsquo;s URL).\nOne way to do this is by integrating these links in a specific page using iframes. You may argue that using iframes is a very legacy approach, yes, you are right.\nRecommended read: Good reasons why not to use Iframes in page content\n A Recommended way to integrate on client side is using Web Components and frameworks such as single SPA\nFrom MDN :\n Web Components is a suite of different technologies allowing you to create reusable custom elements — with their functionality encapsulated away from the rest of your code — and utilize them in your web apps.\n Single SPA is a JS Framework for micro services, which enables developers to build their UI with different JS frameworks.\nServer side Integration As opposed to sending individual components onto client and integrating them together, these UI components are integrated on the server, on user\u0026rsquo;s request a complete pre built web page is delivered to client from server cutting down the loading time on client.\nJust like client side integration process we need to write seperate logic on the server to integrate these micro frontends.\nThese are few of the technologies and frameworks that helps us to achieve this.\n Open Components : An open-source framework to integrate micro frontends components. Server side includes (SSI) : A scripting language used to integrate contents of files onto web pages. Project Mosaic Podium  That\u0026rsquo;s all folks, that pretty much sums up about micro frontends.\nHere is an interesting thread:\n.twitter-tweet { font: 14px/1.45 -apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif; border-left: 4px solid #2b7bb9; padding-left: 1.5em; color: #555; } .twitter-tweet a { color: #2b7bb9; text-decoration: none; } blockquote.twitter-tweet a:hover, blockquote.twitter-tweet a:focus { text-decoration: underline; }  I don’t understand micro-frontends.\n\u0026mdash; дэн (@dan_abramov) May 26, 2019 Until next time, happy learning! 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"A microservice approach to frontend","id":31,"section":"posts","tags":["web-architecture"],"title":"What is Micro Frontends?","uri":"https://gsavitha.in/posts/micro-frontends/"},{"content":"This post requires knowledge of Recursion. If you are new here, its recommended to have a look at that post first.\nMany times, when it comes to recursion, we can guess the recursive solution but it becomes difficult to understand how to write proper base cases so that everything is handled and we do not get stack overflow(incase of java) or segmentation fault(incase of cpp) errors.\nWhat are base cases? Base cases are those inputs, for which we cannot further break down the problem into smaller sub problems.\nLet\u0026rsquo;s consider these examples:\nFinding factorial of a number. (n\u0026gt;=0) 1 2 3 4 5  int factorial(int n){ //recursive solution  return n * factorial(n-1); }   If you see recursive tree for factorial(2) and factorial(3)\ntree tree  factorial(2) |__factorial(1) |__factorial(0)   factorial(3) |__factorial(2) |__factorial(1) |__factorial(0)     'use strict'; var containerId = JSON.parse(\"\\\"c126b1e535f526fa\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \nAfter factorial(0) we cannot break it further. So 0 is the smallest possible value for the problem. Also, every recursive call ends up calling 0, no matter with whichever number you begin with. So we write the base case here as n==0.\n1 2 3 4 5 6  int factorial(int n){ //base case  if(n==0) return 1;  //recursive solution  return n * factorial(n-1); }   Imagine if you have written a wrong base case, lets say you have written a base case as n==1 and there\u0026rsquo;s test case with n=0.\nfactorial(0) |__factorial(-1) |__factorial(-2) |__factorial(-3) |__ ... |__ .. (and so on. it never ends, you end up with stackoverflow or segmentation fault error) Finding nth Fibonacci number (n\u0026gt;=0) 1 2 3 4 5  int fib(int n){ //recursive solution  return fib(n-1) + fib(n-2); }   Now what do we write as base case?\nRemember the same thing, Base cases are those inputs for which we cannot further divide the problem into smaller sub problems.\ntree tree  fib(2) |__fib(1) |__fib(0)   fib(3) |__fib(2) | |__fib(1) | |__fib(0) |__fib(1)     'use strict'; var containerId = JSON.parse(\"\\\"d236c58ca75f0dd3\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Now what are the cases where we cannot divide the problem further?\nDo we handle everything if we just write n==0 as a base case? Is there any other case which we can include other than n==0 ?\nThe case is n==1. If you simply write n==0 as base case what will happen to recursive calls, when someone calls for n==1?\nWhen you skip n==1 as base case, our function will simply call for fib(0) and fib(-1) and fib(-1) is not a valid case for input (since n\u0026gt;=0). Also, fib(-1) further calls fib(-2) and the stack goes on.. which leads to stackoverflow or segmentation fault error.\nIn this example we need to handle two base cases(n==0 \u0026amp; n==1)\n1 2 3 4 5 6 7  int fib(int n){ //base cases  if(n==0) return 0; if(n==1) return 1;  //recursive solution  return fib(n-1) + fib(n-2); }   You can optimise the above code with only one base case\n1 2 3 4 5 6  int fib(int n){ //base case  if(n\u0026lt;=1) return n;  //recursive solution  return fib(n-1) + fib(n-2); }   Hopefully that was helpful to some extent. Until next time, Happy coding! 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"Helps you in writing base cases for recursion","id":32,"section":"posts","tags":["dsa","recursion"],"title":"How to write base cases","uri":"https://gsavitha.in/posts/recursion-base-cases/"},{"content":"Hi There 👋🏻, I\u0026rsquo;m Savitha, a software developer based in India who loves to explore new technologies, build projects, and share my knowledge with others. While I\u0026rsquo;ve worked with many programming languages, I\u0026rsquo;m particularly enthusiastic about JavaScript and its ecosystem ❤️ .\nMy preferred tech stack includes Node.js, Typescript, React, Styled Components, Mongo/Postgres, and Jest. When I\u0026rsquo;m not coding, I enjoy playing video games and chess (even though I\u0026rsquo;m still a beginner!) on chess.com. I\u0026rsquo;m also an avid reader of non-fiction and a music enthusiast. In my free time, I love to capture the world through my camera lens and share my photography on Instagram. Additionally, I enjoy reading books on philosophy and Indian mythology.\nI\u0026rsquo;m always up for discussing and exchanging ideas with others who share my interests. If any of the above fascinates you, or if you have any opportunities, open-source ideas, or need any assistance, feel free to reach out to me via email or Twitter @gsavitha_. If you prefer LinkedIn, you can always send me a connection request with a brief introduction about yourself and your interests or ideas to discuss. You can find me on LinkedIn at @g-savitha. Let\u0026rsquo;s connect and keep the conversation going!\n","description":"about me","id":33,"section":"","tags":null,"title":"About","uri":"https://gsavitha.in/about/"},{"content":"What is recursion? Recursion : A function calling itself directly or indirectly.\nDirectly:\n1 2 3 4 5  void fun1(){ //somecode ...  fun1(); //some other code... }   Indirectly: Not a very common approach (Mostly direct recursive approach is used)\nfun1() -\u0026gt; fun2() -\u0026gt; fun1()\n1 2 3 4 5 6 7 8 9 10 11 12  void fun1(){ //somecode ...  fun2(); //some other code... } void fun2(){ //somecode ...  fun1(); //some other code... }    If you dont add a base case, recursion never stops and we might end up with stackoverflow(in case of java) or segmentation fault error(in case of cpp). There should be one stopping condition atleast. Such stopping conditions are called Base cases  Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  void fun1(int n) { //Base Case  if (n == 0) return; cout \u0026lt;\u0026lt; \u0026#34;Function 1\u0026#34; \u0026lt;\u0026lt; endl; fun1(n - 1); } int main(int argc, char const *argv[]) { /* code */ fun1(2); return 0; }   Typical structure of a recursion (Assuming: You are not using global vars or some other tricks to stop recursion ).\n1 2 3 4 5 6  returntype function(parameters){ Base cases //some other code..... Recursive call (i.e., call to function()) with atleast one change in parameters //some other code... }   Applications of recursion Any problem which can be solved iteratively can also be solved using recursively and vice-versa. They both have same expressive power.\nNow the question is if we can write equivalent iterative code for every recursive code or vice versa, where do we use recursion?\n  Many algorithm techniques are based on recursion.\n Dynamic programming  In DP, generally first solution is to write a recursive solution. If we see overlapping subproblems (apply memoization or tabulation), we use DP to optimise it. Example: Finding diff between two files (solved using LCS approach)   Backtracking  These problems are inherently recursive in nature.  Example : Rat in a maze, n-queens problem. (Its easy to write recursive solns than iterative for problems like this)     Divide and conquer  Examples: Binary search, quicksort and mergesort      Many problems which are inherently recursive (Easy to write recursive than iterative)\n Towers of Hanoi DFS based travels  Of Graphs Inorder, preorder postorder traversals of tree Searching for a file in your pc - solid example of DFS      Cons of recursion\n (Auxillary) space complexity increases Function call overhead.    Pros:\n Easy implementation    Examples cpp cpp cpp  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  void fun1(int n) { if (n == 0) return; //Base Case  cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; fun1(n - 1); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } int main(int argc, char const *argv[]) { /* code */ fun1(3); return 0; } //Output : 321123     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  void fun1(int n) { if (n == 0) return; //Base Case  fun1(n - 1); cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; fun1(n - 1); } int main(int argc, char const *argv[]) { /* code */ fun1(3); return 0; } //Output : 1213121     1 2 3 4 5 6 7 8 9 10 11 12 13 14  int fn(int n) { if (n == 1) return 0; else return 1 + fn(n / 2); } //TC: O(floor(logn base2)) //SC: O(n/2) //fn(16) -\u0026gt; O/p: 4 =\u0026gt; (1+f(8)) -\u0026gt;(1+1+f(4)) -\u0026gt;(1+1+1+f(2)) -\u0026gt; (1+1+1+1+f(1)) //fn(20) -\u0026gt; o/p: 4 =\u0026gt;(1+f(10)) -\u0026gt; (1+1+f(5)) -\u0026gt; (1+1+1+f(2)) -\u0026gt; (1+1+1+1+f(1)) //fn(19) -\u0026gt; o/p:4 =\u0026gt; (1+f(9)) -\u0026gt; (1+1+f(4)) -\u0026gt; -\u0026gt;(1+1+1+f(2)) -\u0026gt; (1+1+1+1+f(1))  //output remains same until we get to next power of 2.       'use strict'; var containerId = JSON.parse(\"\\\"17f48c26f379fb8b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Binary representation of a number(n \u0026gt; 0) using recursion 1 2 3 4 5 6 7  int fn(int n) { if (n == 0) return; fn(n / 2); cout \u0026lt;\u0026lt; n % 2 \u0026lt;\u0026lt; endl; }   Print 1 to N using recursion 1 2 3 4 5 6  private static void fn(int n) { if (n == 0) return; fn(n - 1); System.out.println(n); }//TC; O(n) AS: O(n+1)   Print N to 1 using recursion 1 2 3 4 5 6 7  private static void fn(int n) { if (n == 0) return; System.out.println(n); n(n - 1); }// TC: theta(n) //SC: (Auxillary space) : O(n)    Note: We can reduce the auxillary space using tail recursion.  The above function takes less time on modern compilers because of tail recursion    Tail Recursion To understand tail recursion, lets take a closer look at these 2 functions.\njava java  1 2 3 4 5 6 7  //prints from n to 1 void fn1() { if(n==0) return; System.out.println(n); fn1(n-1); } //this function takes lesser time     1 2 3 4 5 6  //prints from 1 to n void fn2(){ if(n==0) return; fn2(n-1); System.out.println(n); }       'use strict'; var containerId = JSON.parse(\"\\\"8115045dd92aca3b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Can you guess the reason why would 1st function take lesser time to compile on modern compilers?\nIf you look at the call stack of fn1()\n+__fn1(3) |__ 3 |__fn1(2) |__ 2 |__ fn1(1) |__ 1 |__ fn1(0) When fn1(0) finishes, control returns back to fn1(1), fn1(1) doesnt have anything to do it finishes immediately. This is where tail recursion comes into picture.\nA function is called Tail recursive when the parent function has nothing to do when the child finishes the call.\nThis is not the case with fn2(3). When fn2(0) returns to its parent fn2(1), it still has got work to do (print the output).\nIn very simple words\n A function is called tail recursive, when the last thing that happens in the function is recursive call and nothing happens after that.\n What are the pros of this? The point is your caller doesn\u0026rsquo;t have to save the state, generally what happens in recursive calls is, caller\u0026rsquo;s state is saved then called function is called and once the called function is finished then the caller resumes its function from the same point. We dont need to resume the execution here at all, there\u0026rsquo;s no point in resuming the execution and thats what the optimisation modern compilers do.\nWhen modern compilers see tail recursive functions they replace the above code with\n1 2 3 4 5 6 7 8 9  void fn1() { //compiler adds this label  start:  if(n==0) return; System.out.println(n); // and replaces the line fn1(n-1) with below statements  n= n-1 ; goto start; }   These changes that modern compilers make are called Tail call elimination\nNow, the question arises is when given a non tail recursive code, can we convert it tail recursive?\nLets have a look at the below examples.\njava java  1 2 3 4 5 6  //prints from 1 to n void fn2(){ if(n==0) return; fn2(n-1); System.out.println(n); }     1 2 3 4 5 6 7  //Tail recursive version of the code //initially pass k = 1 void fn2(int n, int k){ if(n==0) return; System.out.println(k); fn2(n-1,k+1); }       'use strict'; var containerId = JSON.parse(\"\\\"7116fbcdd1c7ca1d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Can we convert every non tail recursive to tail recursive by adding few parameters?\nNo. Consider merge sort and quick sort, if you take a closer look at these two algorithms, quick sort is tail recursive and merge sort is not. This is one of the reasons, quick sort is fast.\nIn case of tree traversals (Inorder,preorder and postorder), you can notice that preorder traversal and inorder traversal are tail recursive, but post order traversal is not, thats why when you are given a problem and if you can choose any of the traversals, you should prefer either inorder or preorder over the postorder.\nIs this tail recursive? 1 2 3 4  int factorial(int n){ if(n==0 || n== 1) return 1; return n * factorial(n-1); }   No. The reason is recursion is not the last thing that happens in this function. When you call factorial(n-1) you need to know the result of that function and multiply it with n and then it need to return. Parent call doesn\u0026rsquo;t finish immediately after the child call, its going to use the result of child call and then multiply the result with n after that its going to return.\nEquivalent tail recursive code 1 2 3 4 5  //initially pass k = 1 int factorial(int n, int k){ if(n==0 || n== 1) return k; return factorial(n-1,k*n); }   Few problems on recursion worth looking at:\nRod cutting\nGenerate subsets of an array\nJosephus Problem\nPrint all permutations of a string\nSubset sum problem\nUntil next time, happy coding! 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"A function calling itself directly or indirectly is known as recursion.","id":34,"section":"posts","tags":["dsa","recursion"],"title":"Recursion Simplified","uri":"https://gsavitha.in/posts/recursion-simplified/"},{"content":"TL;DR 🚀  If you want to use this.props inside constructor of derived class, use super(props).\n While checking react code, you might have come across a line super(props), sometimes super(). Ever wondered what\u0026rsquo;s the difference between two?\nWhy do we need to pass props ? Do we always need to pass props ?\nConsider the example below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import React, { Component } from \u0026#34;react\u0026#34;; class Game extends Component {  constructor(props) { super(props); this.state = { player: \u0026#34;Robin\u0026#34;, score: 25, }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Cricket\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Current Player :{this.state.player}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Current Score : {this.state.score}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } } export default Game;   Every time we are writing a component, we are extending it from React component (The base component class) and that\u0026rsquo;s really important if we don\u0026rsquo;t do that we would be missing a ton of react functionality.\nLet\u0026rsquo;s step out of react world for just a moment and let\u0026rsquo;s mimic our own component class\n1 2 3 4 5 6 7 8 9 10  class Component { constructor() { console.log(\u0026#34;INSIDE COMPONENT CONSTRUCTOR\u0026#34;); } } class Game extends Component { constructor() { console.log(\u0026#34;INSIDE GAME CONSTRUCTOR\u0026#34;); } }   Lets make a new game\n1  let cricket = new Game();   So you might think, when we initialized a new game, a constructor is called and that should be printed out, unfortunately we get an error\nsays : Must call super constructor before accessing \u0026lsquo;this\u0026rsquo; . Loosely translated, call a super constructor in derived class before basically doing anything.\nProblem is we are extending the base class but we never actually called its constructor and that\u0026rsquo;s super important to do in the derived class\u0026rsquo;s constructor (Inside Game\u0026rsquo;s constructor here), we need to make sure that we\u0026rsquo;re calling the class (it\u0026rsquo;s constructor) we are extending, especially in React because that\u0026rsquo;s how we call all the magic setup stuff that React does and takes care of out of the box for us. so we call super()\n1 2 3 4 5 6  class Game extends Component { constructor() { super();  console.log(\u0026#34;INSIDE GAME CONSTRUCTOR\u0026#34;); } }   Now try to instantiate again.\n1 2 3 4  let cricket = new Game(); //output: //INSIDE COMPONENT CONSTRUCTOR //INSIDE GAME CONSTRUCTOR   What does super(props) do then? Lets look at this example:\n1 2 3 4 5 6 7 8 9 10 11  import React, { Component } from \u0026#34;react\u0026#34;; export default class Food extends Component { render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;HI I AM FOOD COMPONENT\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } }   1 2 3 4 5 6 7 8 9 10 11 12 13  import React, { Component } from \u0026#34;react\u0026#34;; import Food from \u0026#34;./Food\u0026#34;; class App extends Component { render() { return ( \u0026lt;div\u0026gt; \u0026lt;Food item=\u0026#34;PineApple\u0026#34; nutrition=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); } } export default App;   We are passing two props to Food component. You can think of it like we are creating two objects for Food class new Food({item : \u0026quot;pineapple\u0026quot;, nutrition: \u0026quot;10\u0026quot;})\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import React, { Component } from \u0026#34;react\u0026#34;; export default class Food extends Component { constructor() { super(); console.log(this.props); // undefined.  } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;HI I AM FOOD COMPONENT\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } }   We get output as Undefined even though we have props. OK, what\u0026rsquo;s happening here is if we want to access this.props in the constructor, we have to pass props in super (super(props)). This is kind of bizzare, lets consider this example.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import React, { Component } from \u0026#34;react\u0026#34;; export default class Food extends Component { constructor() { super(); console.log(this.props); // undefined.  console.log(props); // {item:\u0026#34;pineapple\u0026#34;, nutrition:10}  } render() { return ( \u0026lt;div\u0026gt;  \u0026lt;h1\u0026gt;{this.props.item}\u0026lt;/h1\u0026gt; /*Prints out pineapple*/ \u0026lt;/div\u0026gt; ); } }   However if you do\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import React, { Component } from \u0026#34;react\u0026#34;; export default class Food extends Component { constructor() { super(props);  console.log(this.props); // {item:\u0026#34;pineapple\u0026#34;, nutrition:10}  } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{this.props.item}\u0026lt;/h1\u0026gt; /*Prints out pineapple*/ \u0026lt;/div\u0026gt; ); } }   To conclude, If you want to use this.props inside constructor, you need to pass props in super(), otherwise it’s okay to not pass props to super() as we see that irrespective of passing it to super(), this.props is available inside render() function.\nHopefully that was not convoluted and crazy, until next time. Happy Coding! 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"If you want to use `this.props` inside constructor of derived class, use super(props)....","id":35,"section":"posts","tags":["react"],"title":"super() vs super(props)","uri":"https://gsavitha.in/posts/super-vs-super-props/"},{"content":"Intro to DOM Events   Events - Responding to user inputs and actions\n  Types of events:(some of the many)\n clicks, drags, drops, hovers,scrolls, form submissions, key press, focus/blur mousewheel, double click, copying, pasting, audio start, screen resize, printing etc.    Note: All events follow a similar pattern\n  Pattern:\n     The thing Event type Code to run     button click change the color   input hits return get the search results   image mouseover display img caption     for more info visit MDN Event reference  2 ways not to add events Lets explore 2 different syntaxes which we should not use.\n all events start with on word. onEventName = doSomething   First type actually involves inline html scripting, which is not recommended. It just clutters the markup.  1 2 3 4 5 6 7 8 9  \u0026lt;button onmouseover=\u0026#34;alert(\u0026#39;You hovered over me!\u0026#39;)\u0026#34;\u0026gt;click me!\u0026lt;/button\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;range\u0026#34; min=\u0026#34;50\u0026#34; max=\u0026#34;100\u0026#34; onclick=\u0026#34;console.log(\u0026#39;clicked the input\u0026#39;)\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt;   We first select an element in Javascript and then do inline html scripting  html js  1  \u0026lt;button id=\u0026#34;clicker\u0026#34;\u0026gt;CLicker!\u0026lt;/button\u0026gt;;     1 2 3 4 5 6 7 8 9 10 11 12 13 14  const clicker = document.querySelector(\u0026#34;#clicker\u0026#34;); clicker.onclick = function () { console.log(\u0026#34;You clicked me\u0026#34;); }; clicker.ondblclick = function () { console.log(\u0026#34;Double click\u0026#34;); }; clicker.onclick = function () { alert(\u0026#34;hello\u0026#34;); }; //now we lost the previous data. //Onclick is considered just like any other property       'use strict'; var containerId = JSON.parse(\"\\\"b991f6d36253a8e7\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }   if you want to have multiple events to a single element use addEventListener  addEventListener Specify the event type and a callback to run\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const button = document.querySelector(\u0026#34;h1\u0026#34;); button.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { alert(\u0026#34;You clicked\u0026#34;); }); button.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { console.log(\u0026#34;Output in console\u0026#34;); }); // we get both things as output for one event. one in console and other as alert button.addEventListener(\u0026#34;mouseover\u0026#34;, function () { button.innerText = \u0026#34;Dont hover on me\u0026#34;; }); // we are permanently changing the innerText, the text doesnt go back to its prev state // to get the text to its prev state. there is another event called `mouseout` use that. button.addEventListener(\u0026#34;mouseout\u0026#34;, function () { button.innerText = \u0026#34;CLick me!\u0026#34;; }); // now text changes back to prev state   addEventListener() is great, because it is just one method and it will attach to any type of event listener you want(click, double click, mouseover etc\u0026hellip;)\n Note: if you see button.onclick property, it is not attached to anything. It returns null as output   important: Dont use arrow functions as call backs, because sometimes we want to access this inside the function and arrow functions doesnt do well with this\n Events on Multiple Elements This is the important topic of event handling. We know how to add multiple events to a single element. how about multiple elements having a single event? How do we take every button on page and add a click event?\n select a group of items u want to add events to loop over them and add eventlistener to each  Note: this refers to individual object onto which we are listening over when adding multiple events\nhtml js  1 2 3 4 5  \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Pick a color\u0026lt;/h1\u0026gt; \u0026lt;section class=\u0026#34;boxes\u0026#34; id=\u0026#34;container\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;script src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt;     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  const colors = [ \u0026#34;red\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;indigo\u0026#34;, \u0026#34;violet\u0026#34;, ]; const boxes = document.querySelector(\u0026#34;#container\u0026#34;); const heading = document.querySelector(\u0026#34;h1\u0026#34;); const pickAColor = function () { console.log(this); heading.style.color = this.style.backgroundColor; }; for (let color of colors) { const box = document.createElement(\u0026#34;div\u0026#34;); box.style.backgroundColor = color; box.classList.add(\u0026#34;box\u0026#34;); boxes.appendChild(box); box.addEventListener(\u0026#34;click\u0026#34;, pickAColor); } ```       'use strict'; var containerId = JSON.parse(\"\\\"cdc69765086e5825\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Important : So when the function pickAColor is called, ie., when we click on a box, we are never executing pickAColor ourselves, its being called for us. An Event object is passed to it. Event object is automatically called every time we are not capturing it\nEvent Object Contains information about a particular event\n1 2 3  const pickAColor = function (evt) { console.log(evt); //MouseEvent Object is returned };   1 2 3  document.body.addEventListener(\u0026#34;keypress\u0026#34;, function (e) { console.log(e); }); //RT: KeyboardEvent    KeyboardEvent - Conatins info about the key we pressed and othe useful info about keys  Key Events There are atleast 3 types of keyevents.\n keyup keydown keypress  keydown A Key has been pressed.\nWhen u hold or press any key it is considered as keydown event.\n  Note: keydown runs for any potential keys whether they actually change the input or not\n  All key presses are considered as keydown events.\n eg: alt/option, cmd, ctrl, caps, all alphabets, space, shift, tab etc.\nhtml js  1  \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; placeholder=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt;     1 2 3 4 5  const username = document.querySelector(\u0026#34;#username\u0026#34;); //we would want event object, because it contain info about which key is pressed username.addEventListener(\u0026#34;keydown\u0026#34;, function (e) { console.log(\u0026#34;KEY DOWN\u0026#34;); });       'use strict'; var containerId = JSON.parse(\"\\\"d67377edd768bbdd\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }     keyup A key has been released.\nFor all keys, first a keydown event is fired followed by a keyup.\n Note: keyup only occurs when u release a key  1 2 3 4 5 6 7 8  const username = document.querySelector(\u0026#34;#username\u0026#34;); username.addEventListener(\u0026#34;keydown\u0026#34;, function (e) { console.log(\u0026#34;KEY DOWN\u0026#34;); }); username.addEventListener(\u0026#34;keyup\u0026#34;, function (e) { console.log(\u0026#34;KEY UP\u0026#34;); });   keypress A key that normally produces a character value has been pressed. If the key is not a modifier key, the keypress event is sent\n Caution: This event is obsolete and differs from browser to browser, better not to use it much\n   When you type a key K in the input. The order of key sequenes would be Keydown, keypress, keyup\n  When you press something like shift we only get keydown and keyup\n  Capital letter -\u0026gt; Shift + Letter -\u0026gt; KeyDown(2) , keypress, keyup(2) -\u0026gt; keydown and keyup for both shift and letter\n  Note: keypress only works when we have changing input. like alphabets, doesnt work with arrows, caps, shift, tab, cmd etc. But when you hit return, it is considered as a keypress\n  For more on events WEBApi - MDN\n  Example Lets make a todo list\nhtml js  1 2 3  \u0026lt;h1\u0026gt;Shopping list\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;\u0026#34; id=\u0026#34;addItem\u0026#34; placeholder=\u0026#34;add items in your list\u0026#34; /\u0026gt; \u0026lt;ul id=\u0026#34;items\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt;     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const input = document.querySelector(\u0026#34;#addItem\u0026#34;); const ulItems = document.querySelector(\u0026#34;#items\u0026#34;); input.addEventListener(\u0026#34;keypress\u0026#34;, function (e) { // doesnt allow spaces in the beginning  if (e.which === 32 \u0026amp;\u0026amp; !this.value.length) { e.preventDefault(); } if (e.key === \u0026#34;Enter\u0026#34;) { if (!this.value) return; const item = document.createElement(\u0026#34;li\u0026#34;); item.innerText = this.value; console.log(item); this.value = \u0026#34;\u0026#34;; ulItems.appendChild(item); } });       'use strict'; var containerId = JSON.parse(\"\\\"79dd44a0665d1564\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  FormEvents \u0026amp; preventDefault When we press submit, we get navigated to other page or the page gets refreshed if we dont specify any url in action.Lets say we want to stop the form from getting refreshed when we submit. Capture the submit event and stop it from its default behaviour.\nLets take this html snippet\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;form id=\u0026#34;signup\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;credit card\u0026#34; id=\u0026#34;cc\u0026#34; /\u0026gt; \u0026lt;label\u0026gt; I agree to T\u0026amp;C \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;terms\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;select id=\u0026#34;veggies\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;brinjal\u0026#34;\u0026gt;Brinjal\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;tomato\u0026#34;\u0026gt;Tomato\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;onion\u0026#34;\u0026gt;Onion\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt;   preventDefault Default behaviour is prevented\n1 2 3 4  const form = document.querySelector(\u0026#34;#signup\u0026#34;); form.addEventListener(\u0026#34;submit\u0026#34;, function (e) { e.preventDefault(); //when this is executed default behaviour is prevented });   Now this leaves us free to now extract data from the submit event. If we wanted all data at once and send it to an api using AJAX or using a client side request, we can do that. We have flexibility to do something with the data and we can still capture the submit event. What\u0026rsquo;s nice about doing this way as opposed to capturing each input as it changes every single time is we dont need to attach a bunch of event listeners for every input, by adding a submit event listener there\u0026rsquo;s just one event we are waiting for, we tell it not to behave, normally it behaves and then we can extract our data in that function.\n1 2 3 4 5 6 7 8 9 10 11  const creditCardInput = document.querySelector(\u0026#34;#cc\u0026#34;); const termszcheckBox = document.querySelector(\u0026#34;#terms\u0026#34;); const veggiesSelect = document.querySelector(\u0026#34;#veggies\u0026#34;); const form = document.querySelector(\u0026#34;#signup\u0026#34;); form.addEventListener(\u0026#34;submit\u0026#34;, function (e) { console.log(\u0026#34;cc\u0026#34;, creditCardInput.value); //cc 12343434535  console.log(\u0026#34;terms\u0026#34;, termszcheckBox.checked); // terms true  // we get the value from value attribute, eg: we get brinjal as output instead of Brinjal  console.log(\u0026#34;veggiesSelect\u0026#34;, veggiesSelect.value); //veggiesSelect tomato  e.preventDefault(); });   We are accessing data from the form. After accessing these values , we can generally send form data to DB or append something to page using form data. We can put preventDefault() at the top of the function, it still works the same\ninput and change Events input This event is triggered whenever an input changes .We can actually listen to all 3 above inputs(textbox, checkbox and select) at once using a single event type.\nOur goal is to create a datastructure which automatically updates whenever a user enters value in input, instead of waitiing for user to submit(like from the above section)\n1 2 3  creditCardInput.addEventListener(\u0026#34;input\u0026#34;, (e) =\u0026gt; { console.log(\u0026#34;CC Changed\u0026#34;, e); // the event is triggered whenever we type something in the input box });   Storing value to an object as soon as user changes the input. These events trigger before user clicks submit.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const formData = {}; creditCardInput.addEventListener(\u0026#34;input\u0026#34;, (e) =\u0026gt; { console.log(\u0026#34;CC Changed\u0026#34;, e); //formData[\u0026#39;cc\u0026#39;] = creditCardInput.value; -\u0026gt; hard coding. instead use event object properties to get value  formData[\u0026#34;cc\u0026#34;] = e.target.value; }); veggiesSelect.addEventListener(\u0026#34;input\u0026#34;, (e) =\u0026gt; { console.log(\u0026#34;veggie change\u0026#34;, e); formData[\u0026#34;veggie\u0026#34;] = e.target.value; }); termszcheckBox.addEventListener(\u0026#34;input\u0026#34;, (e) =\u0026gt; { console.log(\u0026#34;terms changed\u0026#34;, e); formData[\u0026#34;terms\u0026#34;] = e.target.checked; });   Refactor the above code.\nadd a name attribute to each html input\nhtml js  1 2 3 4 5 6 7 8 9 10  \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;credit card\u0026#34; id=\u0026#34;cc\u0026#34; name=\u0026#34;creditcard\u0026#34; /\u0026gt; \u0026lt;label\u0026gt; I agree to T\u0026amp;C \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;terms\u0026#34; name=\u0026#34;agreeToterms\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;select id=\u0026#34;veggies\u0026#34; name=\u0026#34;selectedVeggie\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;brinjal\u0026#34;\u0026gt;Brinjal\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;tomato\u0026#34;\u0026gt;Tomato\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;onion\u0026#34;\u0026gt;Onion\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt;     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  for (let input of [creditCardInput, termszcheckBox, veggiesSelect]) { input.addEventListener(\u0026#34;input\u0026#34;, (e) =\u0026gt; { if (e.target.type === \u0026#34;checkbox\u0026#34;) formData[e.target.name] = e.target.checked; else formData[e.target.name] = e.target.value; }); } // more sophisticated code for (let input of [creditCardInput, termszcheckBox, veggiesSelect]) { input.addEventListener(\u0026#34;input\u0026#34;, ({ target }) =\u0026gt; { // destructure event object since we only use target  // destructure more coz we use only these 4 properties in target  const [name, type, value, checked] = target; formData[name] = type === \u0026#34;checkbox\u0026#34; ? checked : value; }); }       'use strict'; var containerId = JSON.parse(\"\\\"31ce3dca63579e48\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }   We can add multiple events under single event listener as long as we have name attribute.  change If we change the above event type to change it will still behave the same except for the textbox. Textbox input change wont trigger until we lose focus over it or press return key after entering complete data or focus it, unlike input where it triggers event for every single key typed(every single letter changed in text box).\n1 2 3 4 5 6 7 8  for (let input of [creditCardInput, termszcheckBox, veggiesSelect]) { input.addEventListener(\u0026#34;change\u0026#34;, ({ target }) =\u0026gt; { // destructure event object since we only use target  // destructure more coz we use only these 4 properties in target  const [name, type, value, checked] = target; formData[name] = type === \u0026#34;checkbox\u0026#34; ? checked : value; }); }    This type of pattern (using name attribute) is pretty common especially if we get to something like react and some of the other frameworks or libraries out there. We use name of an input as a key to store the value from that input under, to create a nice object that contains all of our form data at once.\n Hope you learnt something, until next time 👋, happy learning 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"Types of events and how to use them","id":36,"section":"posts","tags":["javascript","DOM","es6","events"],"title":"Event Handling in JS","uri":"https://gsavitha.in/posts/event-handling-in-js/"},{"content":"Want to host a react website? You cant afford paying bills for each and every project?\nWell, Don\u0026rsquo;t worry now you can do that for free with the help of Github Pages. Using GH Pages you can host any website for free in a secured way.\nWhen you host any static website or blog on github servers, basically your domain name would be in this format: {username}.github.io/{repo-name}, if you wish to host it on your own domain, no problem you can do that as well.\nIn this post let\u0026rsquo;s see how to host a react project on GH Pages.\nBefore continuing further, I assume that you know what is Github and how to create a react app. Let\u0026rsquo;s get started\u0026hellip;\nTL;DR 🚀 These are the only commands you need to execute\n1  npm install gh-pages --save-dev   Package.json\n1 2 3 4 5 6 7 8  \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;react-scripts start\u0026#34;, \u0026#34;predeploy\u0026#34;: \u0026#34;npm run build\u0026#34;, \u0026#34;deploy\u0026#34;: \u0026#34;gh-pages -d build\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;react-scripts build\u0026#34;, }, //add homepage property \u0026#34;homepage\u0026#34;: \u0026#34;https://g-savitha.github.io/projectname\u0026#34;   1  npm run deploy   Create a repository First things first, create a repository in your Github profile. For instance I\u0026rsquo;d like to create an app with name deploy-react-app\nNote: If you have already developed a react app and pushed it onto Github you can skip this section..\nCreate react app After creating a repo, Let\u0026rsquo;s create a react app usingcreate-react-app.\n1 2  npx create-react-app deploy-react-app cd deploy-react-app   Once you created a react app and changed into its directory. Run the following commands in terminal/command prompt.\n1 2 3 4 5  git init git add -A git commit -m \u0026#34;initial commit\u0026#34; git remote add origin https://github.com/username/deploy-react-app.git git push origin master   Note: replace username with your own Github username and if you are using ssh instead of https for Github repo add git remote add origin git@github.com:username/deploy-react-app.git\nOnce you pushed your code to Github\u0026hellip;\nDeploy app on GH Pages  Install gh-pages as dev-dependency of react app. 1  npm install gh-pages --save-dev    Add the homepage property in your package.json file. homepage attribute value should be String. http://{username}.github.io/{repo-name} (username must be your Github username and repo-name must be your GitHub repository) 1  \u0026#34;homepage\u0026#34;: \u0026#34;https://g-savitha.github.io/deploy-react-app\u0026#34;    Add the predeploy and deploy properties with existing scripts property in your project\u0026rsquo;s package.json 1 2 3 4 5 6 7 8  \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;react-scripts start\u0026#34;, \u0026#34;predeploy\u0026#34;: \u0026#34;npm run build\u0026#34;, \u0026#34;deploy\u0026#34;: \u0026#34;gh-pages -d build\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;react-scripts build\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;react-scripts test\u0026#34;, \u0026#34;eject\u0026#34;: \u0026#34;react-scripts eject\u0026#34; },   The predeploy script initiates after running our deploy script, which bundles our application for deployment.\n Deploy your application to GH pages. 1  npm run deploy     After succesfully deploying the application, Open your github repository. Go to Settings tab of the repository, scroll down until you reach Github Pages section and choose gh-pages branch as the source.\nBOOM! 💥 your website is hosted on Github pages now.\nOther than Github, you can host your website on Heroku, Vercel, Firebase, Netlify and more. Try out as many as you can to determine which best aligns with your deployment requirements. After all they\u0026rsquo;re free to use 😃.\nFor a good next step, try to add custom domains to your deployed application. It’s good to have a distinctive domain for projects.\nUntil next time, Happy coding! 💻 🎉\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"Host react apps for free on Github Pages.","id":37,"section":"posts","tags":["ghpages","react","hosting"],"title":"Hosting react projects on GH Pages","uri":"https://gsavitha.in/posts/host-react-on-gh-pages/"},{"content":"TL;DR 🚀 These are the only commands you need to sync your forked repo with the original repo\n1 2 3 4 5  git remote add upstream https://github.com/\u0026lt;Original Owner Username\u0026gt;/\u0026lt;Original Repository\u0026gt;.git git fetch upstream git checkout master git merge upstream/master git push   Why should I do this? 😏 Before submitting any pull request, syncing your forked repository with original repository is an important step to perform, as you may want to get the bug fixes or additional features to merge with your code since the time you forked the original repo.\nBut I can do a PR instead.. 💁‍♀️ You can, but that adds an extra commit into your forked repo instead of matching it with the original repo.\nInorder to sync without any additional changes as a part of the process,\n Configure the original repo as upstream remote. Merge changes from original repo Push the merged version back to Github.  Adding original repo as an upstream  Open the forked repo in your Git Bash or command prompt or terminal. List the current configured remote repositories  1 2 3  git remote -v \u0026gt; origin https://github.com/\u0026lt;YOUR_USERNAME\u0026gt;/\u0026lt;YOUR_FORK\u0026gt;.git (fetch) \u0026gt; origin https://github.com/\u0026lt;YOUR_USERNAME\u0026gt;/\u0026lt;YOUR_FORK\u0026gt;.git (push)    Add the original repo as upstream repo  1  git remote add upstream https://github.com/\u0026lt;ORIGINAL_OWNER\u0026gt;/\u0026lt;ORIGINAL_REPOSITORY\u0026gt;.git    Verify the new upstream repo for your forked repo  1 2 3 4 5  git remote -v \u0026gt; origin https://github.com/\u0026lt;YOUR_USERNAME\u0026gt;/\u0026lt;YOUR_FORK\u0026gt;.git (fetch) \u0026gt; origin https://github.com/\u0026lt;YOUR_USERNAME\u0026gt;/\u0026lt;YOUR_FORK\u0026gt;.git (push) \u0026gt; upstream https://github.com/\u0026lt;ORIGINAL_OWNER\u0026gt;/\u0026lt;ORIGINAL_REPOSITORY\u0026gt;.git (fetch) \u0026gt; upstream https://github.com/\u0026lt;ORIGINAL_OWNER\u0026gt;/\u0026lt;ORIGINAL_REPOSITORY\u0026gt;.git (push)   You can now pull the changes from original repo.\nMerge changes from upstream  Open the forked repo in your Git Bash or command prompt or terminal. First things first, fetch the changes (branches and their commits) from upstream  1 2 3 4 5 6 7  git fetch upstream \u0026gt; remote: Counting objects: 75, done. \u0026gt; remote: Compressing objects: 100% (53/53), done. \u0026gt; remote: Total 62 (delta 27), reused 44 (delta 9) \u0026gt; Unpacking objects: 100% (62/62), done. \u0026gt; From https://github.com/\u0026lt;ORIGINAL_OWNER\u0026gt;/\u0026lt;ORIGINAL_REPOSITORY\u0026gt; \u0026gt; * [new branch] master -\u0026gt; upstream/master   Note : Commits to the original repo(master) will be stored in a local branch, upstream/master\n Make sure you are on your local (fork\u0026rsquo;s) master branch  1 2  git checkout master \u0026gt; Switched to branch \u0026#39;master\u0026#39;    The last step, which achieves our goal: Merge changes from original repo (upstream/master) into your forked repo(master).  1 2 3 4  git merge upstream/master \u0026gt; Updating a422352..5fdff0f \u0026gt; Fast-forward \u0026gt; ...   This step brings changes of forked repo in sync with original repo, without losing any uncommited changes :D\nOptional Step If you made changes to your repo and want to push them back to Github\n1  git push origin master   Until next time 👋, Happy learning! 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"This article helps you in pulling changes into your forked repository from the original one.","id":38,"section":"posts","tags":["git","tools","ci-cd","snippets"],"title":"Syncing Git Fork with Original Repository","uri":"https://gsavitha.in/posts/sync-fork-with-original-git/"},{"content":"Setting State Using State We know that setState() is asynchronous…\nSo: it’s risky to assume previous call has finished when you call it. Also, React will sometimes batch (squash together) calls to setState together into one for performance reasons. If a call to setState() depends on current state, the safest thing is to use the alternate “callback form”.\nsetState Callback Form this.setState(callback)\nInstead of passing an object, pass it a callback with the current state as a parameter. The callback should return an object representing the new state.\n1  this.setState((curState) =\u0026gt; ({ count: curState.count + 1 }));   Abstracting State Updates The fact that you can pass a function to this.setState lends itself nicely to a more advanced pattern called functional setState.\nBasically you can describe your state updates abstractly as separate functions. But why would you do this?\n1 2 3 4 5 6  // elsewhere in the code function incrementCounter(prevState) { return { count: prevState.count + 1 }; } // somewhere in the component this.setState(incrementCounter);   Because testing your state changes is as simple as testing a plain function:\n1  expect(incrementCounter({ count: 0 })).toEqual({ count: 1 });    This pattern also comes up all the time in Redux!\n Here is a nice opinionated article on the subject of using functional setState\nMutable Data Structures in State Mutable Data Structures We know how to set state to primitives: mainly numbers and strings. But component state also commonly includes objects, arrays, and arrays of objects.\n1 2 3 4 5 6 7  this.state = { // store an array of todo objects  todos: [ { task: \u0026#34;do the dishes\u0026#34;, done: false, id: 1 }, { task: \u0026#34;vacuum the floor\u0026#34;, done: true, id: 2 }, ], };    You have to be extra careful modifying your array of objects!\n 1 2 3 4 5 6 7 8  completeTodo(id) { const theTodo = this.state.todos.find(t =\u0026gt; t.id === id); theTodo.done = true; // NOOOOO -\u0026gt; WRONG WAY  this.setState({ todos: this.state.todos // bad -\u0026gt; VERY BAD WAY TO SET LIKE THIS  }); }   Why? It’s a long story…\nMutating nested data structures in your state can cause problems w/ React. (A lot of the time it’ll be fine, but that doesn’t matter. Just don’t do it!)\nImmutable State Updates A much better way is to make a new copy of the data structure in question. We can use any pure function to do this…\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  completeTodo(id) { // Array.prototype.map returns a new array  const newTodos = this.state.todos.map(todo =\u0026gt; { if (todo.id === id) { // make a copy of the todo object with done -\u0026gt; true  return { ...todo, done: true }; } return todo; // old todos can pass through  }); this.setState({ todos: newTodos // setState to the new array  }); }   Pure functions such as .map, .filter, and .reduce are your friends. So is the … spread operator.\nThere is a slight efficiency cost due to the O(N) space/time required to make a copy, but it’s almost always worth it to ensure that your app doesn’t have extremely difficult to detect bugs due to mischevious side effects.\nImmutable State Summary  While it sounds like an oxymoron, immutable state just means that there is an old state object and a new state object that are both snapshots in time. The safest way to update state is to make a copy of it, and then call this.setState with the new copy. This pattern is a good habit to get into for React apps and required for using Redux.  Designing State Designing the state of a React application (or any modern web app) is a challenging skill! It takes practice and time! However, there are some easy best-practices that we can talk about in this section to give you a jump-start.\nMinimize Your State In React, you want to try to put as little data in state as possible.\nLitmus test\n does x change? If not, x should not be part of state. It should be a prop. is x already captured by some other value y in state or props? Derive it from there instead.  Bad Example of State Design Let’s pretend we’re modelling a Person…\n1 2 3 4 5 6 7  this.state = { firstName: \u0026#34;Matt\u0026#34;, lastName: \u0026#34;Lane\u0026#34;, birthday: \u0026#34;1955-01-08T07:37:59.711Z\u0026#34;, age: 64, mood: \u0026#34;irate\u0026#34;, };    Does Matt’s first name or last name ever change? Not often I hope… Does Matt’s birthday ever change? How is that even possible! Matt’s age does change, however if we had this.props.birthday we could easily derive it from that. Therefore, the only property here that is truly stateful is arguably mood (although Matt might dispute this 😉).  Fixed Example of State Design 1 2 3 4 5 6 7 8 9 10 11 12  console.log(this.props); { firstName: \u0026#39;Matt\u0026#39;, lastName: \u0026#39;Lane\u0026#39;, birthday: \u0026#39;1955-01-08T07:37:59.711Z\u0026#39;, age: 64 } console.log(this.state); { mood: \u0026#39;insane\u0026#39; }   State Should Live On the Parent Its better to support \u0026ldquo;downward data flow\u0026rdquo; philosophy of React. In general, it makes more sense for a parent component to manage state and have a bunch of “dumb” stateless child display components. This makes debugging easier, because the state is centralized. It’s easier to predict where to find state:\nIs the current component stateless? Find out what is rendering it. There’s the state.\nTodo Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class TodoList extends Component { constructor(props) { super(props); this.state = { todos: [ { task: \u0026#34;do the dishes\u0026#34;, done: false, id: 1 }, { task: \u0026#34;vacuum the floor\u0026#34;, done: true, id: 2 }, ], }; } /* ... lots of other methods ... */ render() { return ( \u0026lt;ul\u0026gt; {this.state.todos.map((t) =\u0026gt; ( \u0026lt;Todo {...t} /\u0026gt; ))} \u0026lt;/ul\u0026gt; ); } }   TodoList is a smart parent with lots of methods, while the individual Todo items are just \u0026lt;li\u0026gt; tags with some text and styling.\nThat\u0026rsquo;s all for now. Until next time 👋, Happy learning 🎉 💻\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"The right approach to  `state`","id":39,"section":"posts","tags":["react"],"title":"React State Patterns","uri":"https://gsavitha.in/posts/react-state-patterns/"},{"content":"Yes you read it right, you can build and host your website in 10 min 😎.\nBut how?\nStatic site generators to the rescue Ok but first, what is a static site? 😕 Basically websites are of two types, static and dynamic. A static site as the name sounds it is - static, constant and fixed. It doesn\u0026rsquo;t change dynamically when a developer makes a change to a file . They just create the static content(HTML and CSS) and upload them on to the server where it remains unchanged.\nWhere as dynamic sites are in almost constant state of change and are powered by servers or Content Management Systems(CMS). Server or CMS builds each page dynamically whenever a change occurs. When a URL is requested to fetch, CMS gets the appropriate data from the DB, loads on HTML, renders the content within template and returns formatted HTML to client\u0026rsquo;s browser. This process is also known as server side processing.\nLooks like CMS website is the solution, then why SSG? 🤷‍♀️ Oh boy, you are a tough cookie. Lets see few of the disadvantages of CMS in brief.\n As CMS started growing popularity, CMS plugins or software have become more vulnerable to cyber attacks and this number is growing. Performance issues. Obviously, because server is doing the more work. Page needs to be loaded each and every time a request is sent, whenever a user visits a site, backend code needs to startup, interact with DB, construct a HTTP response and send it back to server, after all this stuff is done, finally HTML file is returned to display the content.  Ok, how SSGs helps us? Static site generators (SSGs) allow you to have a compromise between writing out a bunch of static html pages and using a potentially heavy (CMS) - retaining the benefits of both 😮 . Cool right? SSGs give us a flexibility to write code dynamically and publish statically.\nSSGs generates all the static pages of your site at once and deploys it to HTTP server.\nFew of the benefits of using SSGs in brief  Speed and performance. Secured. Now we dont have the problems that come with CMS powered websites. Since static website is solely static files, they have no DB - no DB means no chance of getting hacked . Improved cost and reliabilty. As we dont have a DB, we dont get connection errors like failed to establish connection to DB and also less maintenance costs as we dont have DB any more.  Types of SSGs Now, lets look at some of the most popular options.\n Hugo is a very popular SSG which claims itself as a fastest framework for building sites. It is written in Go Next.js is a server-rendered framework developed on top of React. Gatsby.js is built in React and uses GraphQL to manipulate data. It works great with documentation and blogs. Jekyll is written using Ruby.  Enough with words, Let\u0026rsquo;s get started by building a site. Shall we?\nBuild site with Hugo First things first\u0026hellip;\nInstall hugo To install hugo on linux(Ubuntu and Debian) from your terminal, run\n1 2  sudo apt-get install hugo   For other platforms, check the official guide\nCreate a site Once you install hugo, create a hugo site by running\n1 2  hugo new site mywebsite   Select a theme You need to pick a theme before starting. Wish there was some default theme to get started with. Anyways, there are lots of choices over here. I personally recommend to choose Minimo as it is simple to get started with (You can tweak it later), and also i\u0026rsquo;m a great fan of minimalism 😉\nInstalling the theme Basically you can install a theme in 3 ways.\n Download the zip file and unzip it manually in themes folder As a git clone As a git submodule.  I recommend that you avoid the git submodule workflow they suggest on the page. You surely want to tweak the theme in future. Its best to have a repo for both the content and the theme same, as the deployment becomes easier (speaking out of personal experience 😅 , this method gave me a nightmare 😓).\nOk jokes apart. You can download the zip and unzip it manually in the themes/minimo . This method doesn\u0026rsquo;t work greatly all the time.\nSo I recommend to clone the repository. From your terminal run\n1  git clone --depth 1 https://github.com/MunifTanjim/minimo themes/minimo   For installation using other methods and also to tweak the website according to your needs. Check out the official docs\nOnce you have cloned the repo, you need to configure the config.toml . As this is the file, which tells Hugo some details of the configuration to the website you created. So copy the config.toml from the theme whichever you have installed so that you dont accidentally change the theme\u0026rsquo;s info. You can change the info from theme once you are familiar with hugo. If you are a beginner it is not recommended to do so.\n1  cp themes/minimo/exampleSite/config.toml .   That\u0026rsquo;s it your website is created. Tweak the config.toml with your details and start using it. 😃\nAdd content and start the server To start the server, run the following command in terminal\n1  hugo serve -D   -D command builds the static pages.\nYou can create a new post by creating a new .md file, prefixing it with your filename. To create some content run\n1  hugo new posts/firstpost.md   This posts folder automatically gets created in content folder. Edit this newly created file with your content\nIt will look something like this.\n1 2 3 4 5  --- title: \u0026#34;First post\u0026#34; date: 2019-03-26T08:47:11+01:00 draft: true ---   Host and publish the site on your custom domain Once you have created your site. You can host it on github-pages or netlify or vercel or gitlab. My personal favourite is github-pages.\nTo know how to host it on gh-pages, refer this official doc. By hosting the site on the respective platform, you will be given a default domain, you can use it or if you wish to have custom domain. Follow the below steps.\nIf you have hosted it on github pages.\n Go to your repository settings, under github pages, choose gh-pages branch as the source of your website. Under custom domain, add your own domain. Thats it your website is now live! 😍  Few resources to learn hugo Giraffe Academy playlist on youtube\nOfficial Hugo Docs\nLearn more about SSGs here\nIf you found this helpful, please give a shoutout to @gsavitha_ and share this article to help others. For more articles like this, subscribe to my Newsletter and get the latest updates straight to your inbox.\n","description":"Build your own website without CMS using SSGs","id":40,"section":"posts","tags":["hugo","website","portfolio"],"title":"Build your own website in 10 min! with hugo ","uri":"https://gsavitha.in/posts/build-your-own-site/"},{"content":"Thanks for choosing to reach out! I will get back to you shortly.\n","description":"Contact page","id":41,"section":"","tags":null,"title":"Contact Me","uri":"https://gsavitha.in/contact/"}]